<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="初识最大流问题"><meta property="og:title" content="初识最大流问题" />
<meta property="og:description" content="在阅读之前先来提出几个问题。如果这些问题你都知道答案那就可以直接跳过，期待下一篇文章了：
 什么是网络流模型？ 网络流有哪些经典问题？ 哪些问题能转化成网络流问题？  这篇文章会用一个描述的方式来先认识这些概念问题，而代替很多书上的符号标记。
流网络与最大流问题 首先网络流问题都是建立在流网络上的。这一点不要弄混，所谓流网络首先它是一个有向图，并且图中每条边都有一个非负的容量值。这个容量值我们暂时可以理解成边的权，但是这个权有着它自身的含义。我们来针对流网路举一个例子：
 假设有这么一个例子，这次 2019-nCoV 疫情让口罩变成了稀缺资源。所以，全国各地都在为武汉捐献物资。假设现在因为种种原因，我们只能通过地面线路来运输口罩物资，并且每一条线路是有流量限制的。假设不考虑运输速度，并且源点 S （杭州）的口罩物资产量是足够多的，我们需要求解汇点 T（武汉）在不计速度的情况下能收到多少物资？
 上面的流网络可能我们很难一眼看出答案，那么我们先简化一下场景。我们删几条边来看下这个问题：
对于这个流网络，我们可以轻松的获得汇点 T 的最大流量。
因为在这个图中，只有两条路径，本别是 S → A → B → T 和 S → C → D → T 两条路径来输送流量，前者最大流量是 12 ，后者是 4，所以最大流量总和是 16。
这其实就是流网络的一个经典问题模型 —— 最大流问题（Maximum-Flow Problem）。
网络流问题的一些关键概念 在上述场景中，我们讲述了最大流问题是在研究什么样的问题。接下来，我们来定义一些网络流问题当中的一些关键概念。这些概念有助于理解以后学习网络流中出现的各种名词。
什么是增广路？ 首先我们来说什么是增广（Augmenting）？在最大流问题中，我们每次找的一条可以增加汇点流量的路径，即在网络中找出一条可以到汇点 T 的道路，并且求出这条道路所有边剩余容量的最小值 d，并在上所有边的流量都加上这个 d，这个过程就是增广。而增广路（Augmenting Path）就是这条可以给 T 带来更多流量的路径。
比如上图中，S → A → B → T 和 S → C → D → T 就是两条增广路。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part4/ch03/1-maximum-flow-basic/" />

<title>初识最大流问题 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/">时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/">快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/">矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/">快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/">RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/"class=active>*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>初识最大流问题</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#流网络与最大流问题">流网络与最大流问题</a></li>
        <li><a href="#网络流问题的一些关键概念">网络流问题的一些关键概念</a>
          <ul>
            <li><a href="#什么是增广路">什么是增广路？</a></li>
            <li><a href="#最大流中的增广路定理">最大流中的增广路定理</a></li>
            <li><a href="#什么是残余网络">什么是残余网络？</a></li>
          </ul>
        </li>
        <li><a href="#最小割最大流定理">最小割最大流定理</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>初识最大流问题</h1><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/title.png" alt="头图"></p>
<p>在阅读之前先来提出几个问题。如果这些问题你都知道答案那就可以直接跳过，期待下一篇文章了：</p>
<ul>
<li>什么是网络流模型？</li>
<li>网络流有哪些经典问题？</li>
<li>哪些问题能转化成网络流问题？</li>
</ul>
<p>这篇文章会用一个描述的方式来先认识这些概念问题，而代替很多书上的符号标记。</p>
<h2 id="流网络与最大流问题">流网络与最大流问题</h2>
<p>首先网络流问题都是建立在流网络上的。这一点不要弄混，所谓流网络首先它是一个有向图，并且图中每条边都有一个非负的容量值。这个容量值我们暂时可以理解成边的权，但是这个权有着它自身的含义。我们来针对流网路举一个例子：</p>
<blockquote>
<p>假设有这么一个例子，这次 2019-nCoV 疫情让口罩变成了稀缺资源。所以，全国各地都在为武汉捐献物资。假设现在因为种种原因，我们只能通过地面线路来运输口罩物资，并且每一条线路是有流量限制的。假设不考虑运输速度，并且源点 S （杭州）的口罩物资产量是足够多的，我们需要求解汇点 T（武汉）在不计速度的情况下能收到多少物资？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-origin-problem.png" alt="问题原型"></p>
<p>上面的流网络可能我们很难一眼看出答案，那么我们先简化一下场景。我们删几条边来看下这个问题：</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-simple-problem.png" alt="简化问题"></p>
<p>对于这个流网络，我们可以轻松的获得汇点 <code>T</code> 的最大流量。</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-solve-problem.png" alt="最大流求解"></p>
<p>因为在这个图中，只有两条路径，本别是 <code>S → A → B → T</code> 和 <code>S → C → D → T</code> 两条路径来输送流量，前者最大流量是 12 ，后者是 4，所以最大流量总和是 16。</p>
<p>这其实就是流网络的一个经典问题模型 —— <strong>最大流问题（Maximum-Flow Problem）</strong>。</p>
<h2 id="网络流问题的一些关键概念">网络流问题的一些关键概念</h2>
<p>在上述场景中，我们讲述了最大流问题是在研究什么样的问题。接下来，我们来定义一些网络流问题当中的一些关键概念。这些概念有助于理解以后学习网络流中出现的各种名词。</p>
<h3 id="什么是增广路">什么是增广路？</h3>
<p>首先我们来说什么是增广（Augmenting）？在最大流问题中，我们每次找的一条可以增加汇点流量的路径，即在网络中找出一条可以到汇点 T 的道路，并且求出这条道路所有边剩余容量的最小值 d，并在上所有边的流量都加上这个 d，这个过程就是增广。而增广路（Augmenting Path）就是这条可以给 T 带来更多流量的路径。</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-augmenting-path.png" alt="什么是增广路"></p>
<p>比如上图中，<code>S → A → B → T</code> 和 <code>S → C → D → T</code> 就是两条增广路。</p>
<h3 id="最大流中的增广路定理">最大流中的增广路定理</h3>
<p>由上面的定义，可以知道当一个流网络中，仍旧存在增广路的时候，此时汇点 T 是可以继续增加流量的，所以此时的情况肯定没有达到最大流。</p>
<p>反之，<strong>当且仅当网络中不存在 S-T 有增广路时，此时的流是从 S 到 T 的最大流</strong>。这个就是最大流中的增广路定理。</p>
<h3 id="什么是残余网络">什么是残余网络？</h3>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-one-augmenting-path.png" alt="残余网络"></p>
<p>继续用上文中的那个场景，当已经选出 <code>S → A → B → T</code> 这条增广路的时候，我们将已经消费的流量记录在每条边流量的左方。像这种已经消费部分流量的网络，我们将其叫做<strong>残余网络</strong>（Residual network）。</p>
<h2 id="最小割最大流定理">最小割最大流定理</h2>
<p>首先先了解一下什么是最小割，对于一个有向图，已知原点 S 和汇点 T。当我们拆掉图中的某几条边使得没有从 S 到 T 的通路，并保证所减的边的权重和最小。</p>
<p>在上面的例子中，相信大家很快就能找到这两条边，那就是 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \(AB\)
</span>
 和 

<span class="katex">
  \(DT\)
</span>
 。我们用图来说明一下：</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-minimum-cut.png" alt="最小割"></p>
<p>当通过割线 <code>l</code> 来删除 

<span class="katex">
  \(AB\)
</span>
 和 

<span class="katex">
  \(DT\)
</span>
 ，此时发现起点 S 已经无法走到汇点 T 了。我们将这样的集合划分 

<span class="katex">
  \((S, T)\)
</span>
 称为 

<span class="katex">
  \(s-t\)
</span>
 割，且具有容量定义：</p>


<span class="katex">
  \[
c(S, T)=\sum_{u \in S,v \in T}^{} c(u, v)
\]
</span>

<p>这个式子左边的意思就是我们将这个图通过割线的分割后，就出现了 S, T 两部分，即包含起点 S 的部分和包含汇点 T 的部分。</p>
<p>而式子右边的意思是我们从 S 部分任取一个点，从 T 部分任取一个点，假设 <code>uv</code> 是一条边，则我们把这种情况的所有边容量加和。这里的加和要以 S 到 T 为正向，则反向的容量就是负权。根据这种描述，我们就可以将图转化成以下模型：</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part4/ch03/1-maximum-flow-basic/mf-group-model.png" alt="流与割的关系"></p>
<p>假设 <code>f(u, v)</code> 代表是从 <code>u</code> 节点到 <code>v</code> 节点流过的流量，那么对于上面 S、T 两个虚拟的集合节点来说，肯定就有以下公式：</p>


<span class="katex">
  \[
f(S, T) \leq c(S,T)
\]
</span>

<p>而流量什么时候到达最大值 <code>c(S, T)</code> 呢，我们上文说过，<strong>当没有其他增广路的时候</strong>。所以我们说，在最大流问题中，<strong>一个流网络的最大流等于其最小割</strong>。</p>
<h2 id="小结">小结</h2>
<p>以上讨论中，我们已经学习了在网络流当中的一些相对重要的定义。根据上面的分析，你应该清楚如果我们想解决最大流问题，首先应该<strong>实现找到增广路的算法。</strong></p>
<p>但是只找到增广路就可以解决了吗？你可以用上文提到的没有删减边的例子再试试。</p>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#流网络与最大流问题">流网络与最大流问题</a></li>
        <li><a href="#网络流问题的一些关键概念">网络流问题的一些关键概念</a>
          <ul>
            <li><a href="#什么是增广路">什么是增广路？</a></li>
            <li><a href="#最大流中的增广路定理">最大流中的增广路定理</a></li>
            <li><a href="#什么是残余网络">什么是残余网络？</a></li>
          </ul>
        </li>
        <li><a href="#最小割最大流定理">最小割最大流定理</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












