<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="快速素数筛法"><meta property="og:title" content="快速素数筛法" />
<meta property="og:description" content="本文的内容实用而且简单！素数问题是从来都是数学家热衷探索的领域，也是程序设计竞赛和 LC 中，解决数论相关问题的基础，下面本文介绍如何更科学地筛素数和一些相关的小知识。
首先从定义来说， **素数，指整数在一个大于 1 的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。**那么首先我们可以根据定义来写出我们的最暴力求解素数的程序
暴力统计素数 假设有 n 个数，我们的方法很简单，判断每个数是否有其他因子，如果有则不是素数，时间复杂度为 O(nlogn)。
我们以的题目 《LeetCode-204 计数质数》 为例，题目描述：
统计所有小于非负整数 n 的质数的数量。
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
 我们可以写出如下程序：
class Solution: def countPrimes(self, n: int) -&gt; int: ans = 0 for i in range (2, n): flag = True # 只需要检查小于等于sqrt(n)的因数就可以了,因为大于的那部分一定对应着一个小于sqrt(n)的因数 for j in range(2, int(math.sqrt(i)) &#43; 1): if 0 == i % j: flag = False break if flag: ans &#43;= 1 return ans 功能上来说，我们的已经完全实现对素数进行计数，但是提交结果超出时间限制。所以接下来我们要改进一下算法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part2/ch02/1-eratos-sive/" />

<title>快速素数筛法 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/">时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/">快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/">矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/"class=active>快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/">RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/">*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>快速素数筛法</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#暴力统计素数">暴力统计素数</a></li>
        <li><a href="#eratosthenes-筛法">Eratosthenes 筛法</a></li>
        <li><a href="#欧拉筛法---线性筛">欧拉筛法 - 线性筛</a></li>
        <li><a href="#一个要点">一个要点</a>
          <ul>
            <li><a href="#这段代码怎么解释">这段代码怎么解释？</a></li>
          </ul>
        </li>
        <li><a href="#复杂度对比">复杂度对比</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>快速素数筛法</h1><p>本文的内容实用而且简单！素数问题是从来都是数学家热衷探索的领域，也是程序设计竞赛和 LC 中，解决数论相关问题的基础，下面本文介绍如何更科学地筛素数和一些相关的小知识。</p>
<p>首先从定义来说， **素数，指整数在一个大于 1 的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。**那么首先我们可以根据定义来写出我们的最暴力求解素数的程序</p>
<h2 id="暴力统计素数">暴力统计素数</h2>
<p>假设有 <code>n</code> 个数，我们的方法很简单，判断每个数是否有其他因子，如果有则不是素数，时间复杂度为 <strong><code>O(nlogn)</code></strong>。</p>
<p>我们以的题目 <a href="https://leetcode-cn.com/problems/count-primes/">《LeetCode-204 计数质数》</a> 为例，题目描述：</p>
<blockquote class="book-hint info">
  <p>统计所有小于非负整数 n 的质数的数量。</p>
<p>输入: 10</p>
<p>输出: 4</p>
<p>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>

</blockquote>

<p>我们可以写出如下程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countPrimes</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range (<span style="color:#ae81ff">2</span>, n):
            flag <span style="color:#f92672">=</span> True
            <span style="color:#75715e"># 只需要检查小于等于sqrt(n)的因数就可以了,因为大于的那部分一定对应着一个小于sqrt(n)的因数</span>
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, int(math<span style="color:#f92672">.</span>sqrt(i)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> i <span style="color:#f92672">%</span> j:
                    flag <span style="color:#f92672">=</span> False
                    <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">if</span> flag:
                ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><p>功能上来说，我们的已经完全实现对素数进行计数，但是提交结果超出时间限制。所以接下来我们要改进一下算法。</p>
<h2 id="eratosthenes-筛法">Eratosthenes 筛法</h2>
<p><em>Eratosthenes</em> 筛法进行的是打表，也就是平时说的离线操作，当查询量比较大的时候，我们往往采用这种方法进行离线操作处理；该算法的内容是：首先假设 <code>n</code> 个数全部都是素数，然后从 <code>2</code> 开始，把<strong>每一个数</strong>的<strong>倍数</strong>都<strong>剔除</strong>并标记成合数（因为合数肯定是有素因子的），这样列表中保存着的都是没有素因子的数，就是我们想要的质数了。</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch02/1-eratos-sive/etato-flow.gif" alt="Eratosthenes 筛法流程"></p>
<p>下面我们对之前的代码进行优化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countPrimes</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        n <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">2</span>, n)   <span style="color:#75715e">#处理输入数字为0的情况</span>
        is_prime <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> [<span style="color:#ae81ff">1</span>] 
        is_prime[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> is_prime[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
            <span style="color:#66d9ef">if</span> is_prime[i]:
                <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
                    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">*</span> j <span style="color:#f92672">&gt;=</span> n: 
                        <span style="color:#66d9ef">break</span>
                    is_prime[i <span style="color:#f92672">*</span> j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">return</span> sum(is_prime)
</code></pre></div><p>显然这道题目比较简单，但是我们还能不能继续对算法进行优化呢？</p>
<p>很明显，很多合数有不止一个素因子，这样上述算法进行了一些重复性的计算，比如对数字 <code>6</code> 来说，素因子 <code>2</code> 和 <code>3</code> 在筛选过程中都对他进行了剔除标记，也就是说，所有 <code>6</code> 的倍数，至少都被 <code>2</code> 和 <code>3</code> 进行了重复的剔除。</p>
<h2 id="欧拉筛法---线性筛">欧拉筛法 - 线性筛</h2>
<p>回忆一下，在我们的暴力算法中，为了简化计算，我们只对小于等于 <code>sqrt(n)</code> 的数进行取余检查；这里可以采取类似但是更简洁的办法，只要保证每个合数<strong>只</strong>会被他的<strong>最小素因子</strong>筛掉就可以了，所以我们优化算法的核心：</p>
<ol>
<li>寻找并保存当前的素数；</li>
<li>对每个数的从小到大的<strong>素数次倍数</strong>进行标记，当发现这个数的素因子后停止（这也就保证每个数都是被<strong>最小素因子</strong>筛掉的）；</li>
</ol>
<p>我们以 <code>i = 21</code> 为例，此时素数表为：<code>2, 3, 5, 7, 11, 13, 17, 19</code></p>
<p>第一轮，标记 <code>2</code> 的倍数，<code>42</code>；</p>
<p>第二轮，标记 <code>3</code> 的倍数，<code>63</code>，这时候我们发现 <code>21</code> 的最小素因子是 <code>3</code></p>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \[
21=3^1\times 7^1
\]
</span>

<p>也就是说 <code>63</code> <strong>必定</strong>是被 <strong><code>21</code> 的最小素因数 <code>3</code></strong> 来标记的，后边的所有素数次倍数也都<strong>至少可以被 <code>3</code> 标记</strong>，就是我们刚才说的重复操作，所以可以选择停止后面的操作节省时间。</p>
<p>这里额外需要一个列表保存已经筛选的素数，下面是我们优化后的代码，时间复杂度为 <code>O(n)</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countPrimes</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        n <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">2</span>, n)
        primes <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> [<span style="color:#ae81ff">0</span>]
        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        is_prime <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> [<span style="color:#ae81ff">1</span>]
        is_prime[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> is_prime[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
            <span style="color:#66d9ef">if</span> is_prime[i]: 
                <span style="color:#75715e"># 保存已经筛出的素数</span>
                primes[cnt] <span style="color:#f92672">=</span> i 
                cnt <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(cnt):
                <span style="color:#75715e"># 如越界则停止</span>
                <span style="color:#66d9ef">if</span> primes[j] <span style="color:#f92672">*</span> i <span style="color:#f92672">&gt;=</span> n: 
                    <span style="color:#66d9ef">break</span> 
                <span style="color:#75715e"># 标记 i 的素数次倍数</span>
                is_prime[primes[j] <span style="color:#f92672">*</span> i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
                <span style="color:#75715e"># 如遇到 i 的素因数，则停止  </span>
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> primes[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>: 
                    <span style="color:#66d9ef">break</span> 
        <span style="color:#66d9ef">return</span> sum(is_prime)
</code></pre></div><h2 id="一个要点">一个要点</h2>
<h3 id="这段代码怎么解释">这段代码怎么解释？</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> primes[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
    <span style="color:#66d9ef">break</span>
</code></pre></div><p>这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。证明如下：</p>
<p>因为 <code>primes[]</code> 数组中的素数是递增的，当 <code>i</code> 能整除 <code>prime[j]</code> 的时候，则 <code>i * prime[j + 1]</code> 这个合数可能能被 <code>prime[j]</code>  乘以某个数筛掉。</p>
<p>因为 <code>i</code> 中含有 <code>prime[j]</code> 且 <code>prime[j]</code> 比 <code>prime[j + 1]</code> 小，即 <code>i = k * prime[j]</code>  ，那么 <code>i * prime[j + 1] = (k * prime[j]) * prime[j + 1] = k' * prime[j]</code>，后面的素数同理。所以不用继续筛下去了。</p>
<p>隐藏，在满足 <code>i % prime[j] == 0</code> 这个条件之前以及第一次满足该条件时，<code>prime[j]</code> 一定是 <code>prime[j] * i</code> 的最小因子。</p>
<h2 id="复杂度对比">复杂度对比</h2>
<p>Eratosthenes 筛法的时间复杂度理论值是 

<span class="katex">
  \(O(Nlog(logN))\)
</span>
 ，而线性筛的理论复杂度是 

<span class="katex">
  \(O(N)\)
</span>
 。可是我通过实际的时间统计，发现 Eratosthenes 筛法更快且更稳定（一脸黑人问号）🌚？如果有读者知道这是怎么一回事，欢迎下方留言。</p>
<p>画图代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> matplotlib <span style="color:#f92672">import</span> pyplot <span style="color:#66d9ef">as</span> plt

x <span style="color:#f92672">=</span> []
y1, y2 <span style="color:#f92672">=</span> [], []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000000</span>, <span style="color:#ae81ff">50000</span>):
    x<span style="color:#f92672">.</span>append(i)
    y1<span style="color:#f92672">.</span>append(eratosthenes_time(i)[<span style="color:#ae81ff">1</span>])
    y2<span style="color:#f92672">.</span>append(euler_time(i)[<span style="color:#ae81ff">1</span>])
    
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;Time Complexity Analysis&#39;</span>)
plt<span style="color:#f92672">.</span>plot(x, y1, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;eratosthenes_sieve&#39;</span>)
plt<span style="color:#f92672">.</span>plot(x, y2, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;euler_sieve&#39;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Parameter Range&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Time Complexity(s)&#34;</span>)

plt<span style="color:#f92672">.</span>legend() <span style="color:#75715e"># 显示图例</span>
</code></pre></div><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch02/1-eratos-sive/compare-graph.png" alt="时间开销比较"></p>
<h2 id="总结">总结</h2>
<p>所以，我们在求解筛素数表的题目，只要使用 Eratosthenes 筛法就可以解决我们 80% 的问题。这种方法即容易理解，又比传统的暴力筛效率提升很多。</p>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#暴力统计素数">暴力统计素数</a></li>
        <li><a href="#eratosthenes-筛法">Eratosthenes 筛法</a></li>
        <li><a href="#欧拉筛法---线性筛">欧拉筛法 - 线性筛</a></li>
        <li><a href="#一个要点">一个要点</a>
          <ul>
            <li><a href="#这段代码怎么解释">这段代码怎么解释？</a></li>
          </ul>
        </li>
        <li><a href="#复杂度对比">复杂度对比</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












