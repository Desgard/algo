<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="RMQ（Range Maximum Query) 问题"><meta property="og:title" content="RMQ（Range Maximum Query) 问题" />
<meta property="og:description" content="今天的算法可能有点难，但是如果我们只需要会使用 RMQ 问题的 ST 算法模板，这种程度就已经可以了！因为 RMQ 问题除了最优解的 ST 算法，剩下的都是高级数据结构的应用，例如：线段树、树状数组、Splay、Treap 甚至是主席树（额，我什么都没有暗示，业界就是这个名字）。好了今天我们从两个角度来解决这个问题。ST 算法和线段树。当然如果你对高级数据结构感兴趣，我也会在以后的文章中更新这个系列。
 注意，学 RMQ 问题与图论没有直接关系，而是 Tarjan 算法中其中的一个重要步骤之一。再次验证了高级算法都是由基础的问题排列组合而来！🧐
这篇文章我们只讲 RMQ 问题以及 RMQ 的最优解法 ST 算法。
引子 RMQ 的英文是 Range Maximum(Minimum) Query，翻译过来其实就是区间求最值的意思。问题描述：对于长度为 n 的数列 A，回答若干询问   \(RMQ(A, i, j)(i, j ，返回数列A中下标在 [i, j] 里的最小(大）值。
在这个问题中，我们需要关注的是查询操作，查询可能是海量的，所以如果我们对数据进行快速的预处理，然后在外面处理后的数据结构中进行快速查询，其实就是最理想的状态。
另外，注意是“在给定的区间内”，那么则说明区间在后续的查询时没有变化。所以我们可以理解成在区间确定后，我们其实已经拿到了所有查询情况的答案！对于这种对给定范围内求值的算法，我们对其归类为离线算法。（当然对应的还有在线算 法，后面讲 Tarjan 算法时我们再详谈）
我们先来尝试下暴力：
nums = [3, 2, 4, 5, 6, 8, 1, 2, 9, 7] def query(l, r): res = nums[0] for i in range(l, r &#43; 1): res = max(res, nums[i]) return res 我们发现每一次查询都是一个 \(O(n)\)  的操作，在海量的查询面前，效率就十分低下了。或许你觉得 \(O(n)\)  还能接受？但是人总是喜新厌旧、择优选择的 🙄 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part2/ch03/1-range-max-query/" />

<title>RMQ（Range Maximum Query) 问题 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/">时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/">快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/">矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/">快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/"class=active>RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/">*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>RMQ（Range Maximum Query) 问题</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#引子">引子</a></li>
        <li><a href="#st-算法解决-rmq-问题">ST 算法解决 RMQ 问题</a>
          <ul>
            <li><a href="#1-预处理">1. 预处理</a></li>
            <li><a href="#2-查询操作">2. 查询操作</a></li>
          </ul>
        </li>
        <li><a href="#st-算法解决-rmq-问题-1">ST 算法解决 RMQ 问题</a></li>
        <li><a href="#结尾">结尾</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>RMQ（Range Maximum Query) 问题</h1><blockquote>
<p>今天的算法可能有点难，<strong>但是如果我们只需要会使用 RMQ 问题的 ST 算法模板</strong>，这种程度就已经可以了！因为 RMQ 问题除了最优解的 ST 算法，剩下的都是<strong>高级数据结构的应用</strong>，例如：<strong>线段树、树状数组、Splay、Treap</strong> 甚至是<strong>主席树</strong>（额，我什么都没有暗示，业界就是这个名字）。好了今天我们从两个角度来解决这个问题。ST 算法和线段树。当然如果你对高级数据结构感兴趣，我也会在以后的文章中更新这个系列。</p>
</blockquote>
<p>注意，学 RMQ 问题与图论没有直接关系，而是 Tarjan 算法中其中的一个重要步骤之一。再次验证了高级算法都是由基础的问题排列组合而来！🧐</p>
<p><strong>这篇文章我们只讲 RMQ 问题以及 RMQ 的最优解法 ST 算法。</strong></p>
<h2 id="引子">引子</h2>
<p>RMQ 的英文是 <strong>Range Maximum(Minimum) Query</strong>，翻译过来其实就是区间求最值的意思。问题描述：对于长度为 n 的数列 A，回答若干询问 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \(RMQ(A, i, j)(i, j <= n)\)
</span>
，返回数列A中下标在 <code>[i, j]</code> 里的最小(大）值。</p>
<p>在这个问题中，我们需要关注的是查询操作，查询可能是海量的，所以如果我们对数据进行快速的预处理，然后在外面处理后的数据结构中进行快速查询，其实就是最理想的状态。</p>
<p>另外，注意是“在给定的区间内”，那么则说明区间在后续的查询时没有变化。所以我们可以理解成在区间确定后，我们其实已经拿到了所有查询情况的答案！对于这种对给定范围内求值的算法，我们对其归类为离线算法。（当然对应的还有在线算 法，后面讲 Tarjan 算法时我们再详谈）</p>
<p>我们先来尝试下暴力：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">nums <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">7</span>]

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">query</span>(l, r):
    res <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(l, r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
        res <span style="color:#f92672">=</span> max(res, nums[i])
    <span style="color:#66d9ef">return</span> res
</code></pre></div><p>我们发现每一次查询都是一个 

<span class="katex">
  \(O(n)\)
</span>
 的操作，在海量的查询面前，效率就十分低下了。或许你觉得 

<span class="katex">
  \(O(n)\)
</span>
 还能接受？但是人总是喜新厌旧、择优选择的 🙄 。</p>
<h2 id="st-算法解决-rmq-问题">ST 算法解决 RMQ 问题</h2>
<p>ST 算法的全名是 <strong>Sparse Table Algorithm</strong>，中文一般管 Sparse Table 称作<strong>稀疏表</strong>。原理是基于二进制的倍增、动态规划思想的。笔者感觉还是有一定难度的。</p>
<p>大概描述一下 ST 算法的两个步骤：</p>
<h3 id="1-预处理">1. 预处理</h3>
<p>ST 算法原理上还是动态规划，我们用  

<span class="katex">
  \(a(1...n) \)
</span>
 表示待查询的一组数，设  

<span class="katex">
  \(f(i, j)\)
</span>
 表示从  

<span class="katex">
  \(a(i)\)
</span>
 到  

<span class="katex">
  \(a(i + 2^j - 1) \)
</span>
 这个范围内的最大值。也就是说 

<span class="katex">
  \(a[i]\)
</span>
 为起点，连续 

<span class="katex">
  \(2^j\)
</span>
 个数的最大值。由于元素个数为 

<span class="katex">
  \(2^j\)
</span>
 个，所以从中间平均分成两部分，每一部分元素个数刚好为 

<span class="katex">
  \(2^{j - 1}\)
</span>
 个，也就是说，把 

<span class="katex">
  \(f(i, j)\)
</span>
 划分成 

<span class="katex">
  \(f(i, j - 1)\)
</span>
 和 

<span class="katex">
  \(f(i + 2^{j - 1}, j - 1)\)
</span>
 。</p>
<p>我画个图来描述一下这个场景：</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch03/1-range-max-query/st-range-show.png" alt="区间描述"></p>
<p>整个区间的最大值一定是左右两部分最大值的较大值，满足动态规划的最优化原理（子状态影响父状态）。很显而易见的状态转移方程：</p>


<span class="katex">
  \[
f(i,j)=max(f(i,j-1),f(i+2^{j-1},j-1)
\]
</span>

<p>边界条件是：</p>


<span class="katex">
  \[
f(i, 0)=a(i)
\]
</span>

<p>这样我们就可以在 

<span class="katex">
  \(O(nlogn)\)
</span>
的复杂度内预处理 f 结果数组。</p>
<p>我们举一个例子，还用上面暴力求职的数据：<code>[3, 2, 4, 5, 6, 8, 1, 2, 9, 7]</code> ，

<span class="katex">
  \(f(1, 0)\)
</span>
 表示第 1 个数起，长度为 

<span class="katex">
  \(2^0 = 1\)
</span>
 的最大值，其实就是 3。</p>
<p>同理</p>
<p>

<span class="katex">
  \[f(1, 1) = max(3, 2) = 3\]
</span>



<span class="katex">
  \[f(1, 2) = max(3, 2, 4, 5) = 5\]
</span>



<span class="katex">
  \[f(1, 3) = max(3, 2, 4, 5, 6, 8, 1, 2) = 8\]
</span>
</p>
<p>规律就是 2 倍增区间。代码实现一下~</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">nums <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">7</span>]

f <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">40</span>)] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">31</span>)]


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rmq_initial</span>():
    n <span style="color:#f92672">=</span> len(nums)
    <span style="color:#66d9ef">for</span> i, num <span style="color:#f92672">in</span> enumerate(nums):
        f[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> num
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">31</span>):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, n):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&gt;=</span> n:
                <span style="color:#66d9ef">break</span>
            f[i][j] <span style="color:#f92672">=</span> max(f[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], f[i <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</code></pre></div><p>查看一下预处理之后的 

<span class="katex">
  \(f\)
</span>
 查询数组：</p>
<pre><code>[3, 3, 5, 8, 8, 0]
[2, 4, 6, 9, 9, 0]
[4, 5, 8, 9, 0, 0]
[5, 6, 8, 9, 0, 0]
[6, 8, 8, 8, 0, 0]
[8, 8, 9, 9, 0, 0]
[1, 2, 9, 0, 0, 0]
[2, 9, 9, 0, 0, 0]
[9, 9, 0, 0, 0, 0]
[7, 0, 0, 0, 0, 0]
</code></pre><p>这是一个什么东西呢，我们先行（其实是 <code>f</code> 数组的第二个下标）来看：</p>


<span class="katex">
  \[
\left\{\begin{matrix}   3&3&5&8&8 \end{matrix}\right\}\tag{1}
\]
</span>

<p>由于我们确定了第一个下标为 0，则这行的含义就是：</p>


<span class="katex">
  \[
\left\{\begin{matrix}   max(3)&max(3, 2)&max(3, 2, 4, 5)&max(3, 2, 4, 5, 7, 8, 1, 2)&max(3, ..., 7) \end{matrix}\right\}
\]
</span>

<p>简单概括就是，对于 <code>f[0][a]</code> 来说，代表的就是 <code>max(nums[0....0 + 2^a)</code>。这是第二个下标的含义。对应的，对于 <code>f[b][0]</code> 来说，代表的就是 <code>max(nums[b - 2 ^ b + 1 ... b])</code> 。好好理解这个数组含义，后面的查询操作就显而易见了。</p>
<h3 id="2-查询操作">2. 查询操作</h3>
<p>我们继续思考区间最大值问题，假设我要查询 <code>[l, r]</code> 这个区间，那么我们如果找到两个子区间，他们的并集精确覆盖到 <code>[l, r]</code> 是不是就满足要求了？</p>
<p>ST 由于使用2倍增，它的边界不好完美覆盖全部 case，所以我们在查询的时候需要简单的做交集操作来约束范围。在上面对于 <code>f</code> 数组的理解中，我们知道了 <code>f</code> 数组的横纵坐标分别代表首末的边界数值，我们的想法就是：为了满足所有区间均可求，我们使用两个范围，确定其最大值和最小值，只要能完全精准覆盖 <code>[l, r]</code>即可求得结果。这里我简单证明一下：</p>
<p>我们假设一个中间量 <code>k</code> ，并满足：</p>


<span class="katex">
  \[
2^k\leq r-l+1\leq2^{k+1}\\
k\leq log_2{(r-l+1)}
\]
</span>

<p>然后我们考虑一下 <strong>l 开始的 

<span class="katex">
  \(2^k\)
</span>
 个数和以 r 结尾的 

<span class="katex">
  \(2^k\)
</span>
 个数</strong> 这个区间是否可以覆盖我们的 

<span class="katex">
  \([l, r]\)
</span>
 区间。当且仅当：</p>


<span class="katex">
  \[
k\geq log_2{(r-l+1)}-1
\]
</span>

<p>取极限，我们令 

<span class="katex">
  \(k = log(r - l + 1)\)
</span>
 ，那么在 <code>f</code> 数组中只需要查询：<code>max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k])</code> 就可以了，是不是很容易？🙄 （其实一点都不容易，但是一般教程都会这么写，我也就这么写，hhhhh）。</p>
<p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch03/1-range-max-query/st-range-union.png" alt="ST区间合并覆盖"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rmq_query</span>(l, r):
    k <span style="color:#f92672">=</span> math<span style="color:#f92672">.</span>log(r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> math<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">return</span> max(f[l][k], f[r <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> k) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][k])
</code></pre></div><p>如此，<strong>我们就通过了 

<span class="katex">
  \(O(1)\)
</span>
 的方式完成了指定区间任意范围的 RMQ</strong>。对于海量数据查询的需求完成了最高度的优化。但是由于 ST 算法需要一个 2 倍增的预处理，<strong>所以整体的复杂度在 O(nlogn)</strong>。如此评估下来，其实如果查询量极少的情况下，我们用暴力法的时间开销 

<span class="katex">
  \(O(n)\)
</span>
 是优于 ST 算法的，但是 ST 是在大量查询的场景下，<strong>所以算法也和业务技术方案一样，有适合于业务的，也有不适合于业务的，一切从业务出发来解决问题就好啦</strong>~</p>
<p>我们掌握了以上方法，尝试着套着 ST 算法的模版，来 A 道题尝试一下，你会立马发现它的奇妙（能解决问题）！</p>
<h2 id="st-算法解决-rmq-问题-1">ST 算法解决 RMQ 问题</h2>
<p>我们来看一道  RMQ 的裸题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5443">HDU-5443 The Water Problem</a></p>
<p>这种题目分两步走，拍上模板，然后写逻辑！HDU 不支持 Python，我们用 C++ 写一版就好啦~</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define maxn 1000000 + 4
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> f[maxn][<span style="color:#ae81ff">20</span>];

<span style="color:#75715e">// 模板
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rmq_initial</span>(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">21</span>; <span style="color:#f92672">++</span> j) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span> i) {
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&gt;=</span> n) <span style="color:#66d9ef">break</span>;
            f[i][j] <span style="color:#f92672">=</span> max(f[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], f[i <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
        }
    }
}

<span style="color:#75715e">// 模板
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rmq_query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) {
    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> log(r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> log(<span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">return</span> max(f[l][k], f[r <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> k) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][k]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T, n;
    cin <span style="color:#f92672">&gt;&gt;</span> T;
    <span style="color:#66d9ef">while</span> (T <span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span> i) {
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>f[i][<span style="color:#ae81ff">0</span>]);
        }
        rmq_initial(n);
        <span style="color:#66d9ef">int</span> l, r, q;
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>q);
        <span style="color:#66d9ef">while</span> (q <span style="color:#f92672">--</span>) {
            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>l, <span style="color:#f92672">&amp;</span>r);
            printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, rmq_query(l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch03/1-range-max-query/st-ac-state.png" alt="HDU-5442-AC-STATE"></p>
<h2 id="结尾">结尾</h2>
<p>RMQ 问题其实还有很多解发，笔者比较常用的就是 ST 算法和线段树。但是 ST 算法无论从空间复杂度、时间复杂度还是代码量上来看，都优于线段树，但是 ST 算法往往只局限在 RMQ 问题，而具有区间操作的线段树的变化更加灵活，并且是在线查询，可以支持数据源的变化。所以在业务场景下，多变性和业务健壮性的工程角度来看，线段树是一个更加不错的选择。下一篇文章我们来讨论如何利用线段树来解决 RMQ 的问题。</p>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#引子">引子</a></li>
        <li><a href="#st-算法解决-rmq-问题">ST 算法解决 RMQ 问题</a>
          <ul>
            <li><a href="#1-预处理">1. 预处理</a></li>
            <li><a href="#2-查询操作">2. 查询操作</a></li>
          </ul>
        </li>
        <li><a href="#st-算法解决-rmq-问题-1">ST 算法解决 RMQ 问题</a></li>
        <li><a href="#结尾">结尾</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












