<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="快速幂取模算法"><meta property="og:title" content="快速幂取模算法" />
<meta property="og:description" content="上一篇文章我们讲了如何将幂运算优化到   \(O(logN)\)  的方法。这一篇来研究一下，快速幂算法与取模运算是如何结合的。
取余和取模 首先我们要知道在编程语言中有 % 这么一个操作符，在各大编程书中称之为“取余运算”。在程序设计和抽象数学领域，我们管这个操作叫做：取模运算。
下面以整型 a 和 b 两个变量举例，在我们常说的取余运算中，其算法会分成以下的两个步骤：
 求整数商：c = a / b 求余数：r = a - c * b  取模与取余不同在于第一步，求余在整除的时候是往 0 方向逼近，而取模是往负无穷方向逼急。这样就造成了在对负数进行取模运算的差异。所以在计算 -7 % 4 的时候，求余运算的结果是 -3，而取模运算是 1。
/// 第一步：求整数商 // 求余运算 -7 / 4 = -1 (逼近 0 ) // 求模运算 -7 / 4 = -2 (逼近负无穷) /// 第二步： // 求余运算 -7 - -1 * 4 = -7 &#43; 4 = -3 // 求模运算 -7 - -2 * 4 = -7 &#43; 8 = 1 当然，逼近方向其实不影响其他的运算规律，因为任意的 a % b，对于给定的 a 和 b ，计算结果一定是一个确定的值。所以我们只需了解这两种计算的区别就可以。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part2/ch01/2-quick-pow-mod/" />

<title>快速幂取模算法 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/">时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/"class=active>快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/">矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/">快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/">RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/">*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>快速幂取模算法</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#取余和取模">取余和取模</a></li>
        <li><a href="#不同语言的--运算符表现">不同语言的 <code>%</code> 运算符表现</a>
          <ul>
            <li><a href="#python"><strong>Python</strong></a></li>
            <li><a href="#ccjavaswift"><strong>C/C++/Java/Swift</strong></a></li>
          </ul>
        </li>
        <li><a href="#求模运算的规律">求模运算的规律</a></li>
        <li><a href="#结合快速幂算法">结合快速幂算法</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>快速幂取模算法</h1><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch01/2-quick-pow-mod/title.png" alt="题头"></p>
<p>上一篇文章我们讲了如何将幂运算优化到 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \(O(logN)\)
</span>
 的方法。这一篇来研究一下，快速幂算法与取模运算是如何结合的。</p>
<h2 id="取余和取模">取余和取模</h2>
<p>首先我们要知道在编程语言中有 <code>%</code> 这么一个操作符，在各大编程书中称之为“取余运算”。在程序设计和抽象数学领域，我们管这个操作叫做：<strong>取模运算</strong>。</p>
<p>下面以整型 <code>a</code> 和 <code>b</code> 两个变量举例，在我们常说的取余运算中，其算法会分成以下的两个步骤：</p>
<ol>
<li>求整数商：<code>c = a / b</code></li>
<li>求余数：<code>r = a - c * b</code></li>
</ol>
<p>取模与取余不同在于第一步，求余在整除的时候是往 0 方向逼近，而取模是往负无穷方向逼急。这样就造成了在对负数进行取模运算的差异。所以在计算 <code>-7 % 4</code> 的时候，求余运算的结果是 <code>-3</code>，而取模运算是 <code>1</code>。</p>
<pre><code>/// 第一步：求整数商
// 求余运算
-7 / 4 = -1 (逼近 0 )

// 求模运算
-7 / 4 = -2 (逼近负无穷)

/// 第二步：
// 求余运算
-7 - -1 * 4 = -7 + 4 = -3

// 求模运算
-7 - -2 * 4 = -7 + 8 = 1
</code></pre><p>当然，逼近方向其实不影响其他的运算规律，因为任意的 <code>a % b</code>，对于给定的 <code>a</code> 和 <code>b</code> ，计算结果一定是一个确定的值。所以我们只需了解这两种计算的区别就可以。</p>
<h2 id="不同语言的--运算符表现">不同语言的 <code>%</code> 运算符表现</h2>
<h3 id="python"><strong>Python</strong></h3>
<p><code>%</code> 在不同的语言中，可能会表现出不同的运算。例如在 python 中，<code>%</code> 是取模运算，另外整除的表现也是像负无穷无限逼近，以及 <code>divmod</code> 也是求模的表现。（以下是使用 iPython 的调试结果）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">In <span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: -7 % <span style="color:#ae81ff">4</span>
Out<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: <span style="color:#ae81ff">1</span>

In <span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>: divmod<span style="color:#f92672">(</span>-7, 4<span style="color:#f92672">)</span>
Out<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>: <span style="color:#f92672">(</span>-2, 1<span style="color:#f92672">)</span>

In <span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>: -7 // <span style="color:#ae81ff">4</span>
Out<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>: -2
</code></pre></div><h3 id="ccjavaswift"><strong>C/C++/Java/Swift</strong></h3>
<p><code>%</code> 在 <strong>C/C++/Java</strong> 中均为<strong>求余运算</strong>的表现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// C++
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// -1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// -3
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// Java
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMod</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span>args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(-</span>7 <span style="color:#f92672">/</span> 4<span style="color:#f92672">);</span> <span style="color:#75715e">// -1
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(-</span>7 <span style="color:#f92672">%</span> 4<span style="color:#f92672">);</span> <span style="color:#75715e">// -3
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#75715e">// Swift</span>
print(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>) <span style="color:#75715e">// -1</span>
print(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>) <span style="color:#75715e">// -3</span>
</code></pre></div><p>只有掌握了在各个语言中的不同表现，我们才能在解题的时候知道具体的运算流程，否则当遇到求模处理时，由于语言的迁移使用而造成了想当然的情况。</p>
<h2 id="求模运算的规律">求模运算的规律</h2>
<p>这里我直接给出规律，如果想看证明请自行 Google。</p>
<pre><code>(a + b) % p = (a % p + b % p) % p 
(a - b) % p = (a % p - b % p + p) % p 
(a * b) % p = (a % p * b % p) % p 
a ^ b % p = ((a % p)^b) % p 
</code></pre><h2 id="结合快速幂算法">结合快速幂算法</h2>
<p>终于来到了最关键的地方，结合快速幂算法后会有什么影响呢？</p>
<p>其实在我们日常做题中，你会看到<strong>输出结果对 xxxx 取模</strong>。这种题目可能是有两种考察方向:</p>
<ol>
<li><strong>在原算法的基础上，多一个取模运算来考察你对取模运算规律的掌握；</strong></li>
<li><strong>大数据时数据增长太快，64 位甚至 128 位的整形无法表示；</strong></li>
</ol>
<p>对应的，我们快速幂的题目就是这样，假设让你求 a 的 b 次方，当 <code>a = 10</code> 且 <code>b = 20</code> 次方就已经超过了 64 位 <code>Int</code> 类型的范围（

<span class="katex">
  \(2^{64}\)
</span>
 次方约等于 <code>1.84 * 10^19</code>）。</p>
<p>所以，接下来我们要把求模运算也加入到快速幂运算中，我们先来观察上一篇文中所使用到的快速幂算法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qpow</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">*=</span> x; <span style="color:#75715e">// 关注点 1
</span><span style="color:#75715e"></span>        x <span style="color:#f92672">*=</span> x; <span style="color:#75715e">// 关注点 2
</span><span style="color:#75715e"></span>        n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}
</code></pre></div><p>我们来看关注点 1 和关注点 2 两个地方，分析得到这两个结论：</p>
<ol>
<li>我们的快速幂算法其实并没有真正的优化乘法效率，而是通过二进制拆分，从而优化了乘法运算的次数，具体的表现就是 <code>x *= x</code> 来扩大乘子的基数；</li>
<li>在计算 <code>res</code> 的时候，<code>res *= x</code> 仍旧是一个累乘的过程，唯一的变化就是 <code>x</code> 在由于 <code>x *= x</code> 逐渐变化。这两个式子结合起来，其实就是 <code>res</code> 不断的去累乘多个 <code>x</code> 。</li>
</ol>
<p>有了这两点分析，我们就可以套用求模运算规律了。</p>
<pre><code>(a * b) % p = (a % p * b % p) % p 
</code></pre>
<p>我们在所有乘法表达式的地方增加求模运算，其实反映出来的结果就是 <code>res</code> 不断累乘时候每一项都做一次求模运算。</p>
<p>有着以上思路我们来修改代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qpow</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m) {
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> x <span style="color:#f92672">%</span> m;
        x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> x <span style="color:#f92672">%</span> m;
        n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> qpow(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">997</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> qpow(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">997</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 100
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>好了，有了这两篇文章的知识点，你可以自己来尝试 <a href="https://leetcode-cn.com/classic/problems/super-pow/description/">[LeetCode-372] 超级次方</a> 这道题目了。</p>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#取余和取模">取余和取模</a></li>
        <li><a href="#不同语言的--运算符表现">不同语言的 <code>%</code> 运算符表现</a>
          <ul>
            <li><a href="#python"><strong>Python</strong></a></li>
            <li><a href="#ccjavaswift"><strong>C/C++/Java/Swift</strong></a></li>
          </ul>
        </li>
        <li><a href="#求模运算的规律">求模运算的规律</a></li>
        <li><a href="#结合快速幂算法">结合快速幂算法</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












