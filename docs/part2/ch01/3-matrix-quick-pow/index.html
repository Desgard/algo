<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="矩阵快速幂"><meta property="og:title" content="矩阵快速幂" />
<meta property="og:description" content="回顾 在上一篇文章中，我们对快速幂算法进行了如下的分析：
int qpow(int x, int n, int m) { int res = 1; while (n) { if (n &amp; 1) res = res * x % m; x = x * x % m; n &gt;&gt;= 1; } return res; } int main() { cout &lt;&lt; qpow(10, 3, 997) &lt;&lt; endl; // 3  cout &lt;&lt; qpow(10, 2, 997) &lt;&lt; endl; // 100  return 0; }  我们的快速幂算法其实并没有真正的优化乘法效率，而是通过二进制拆分，从而优化了乘法运算的次数，具体的表现就是 x *= x 来扩大乘子的基数； 在计算 res 的时候，res *= x 仍旧是一个累乘的过程，唯一的变化就是 x 在由于 x *= x 逐渐变化。这两个式子结合起来，其实就是 res 不断的去累乘多个 x 。  其中的关键就是快速幂其实没有真正优化乘法的效率，而是优化了乘法运算的次数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part2/ch01/3-matrix-quick-pow/" />

<title>矩阵快速幂 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/">时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/">快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/"class=active>矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/">快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/">RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/">*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>矩阵快速幂</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#回顾">回顾</a></li>
        <li><a href="#斐波那契万物之源">斐波那契，万物之源</a></li>
        <li><a href="#矩阵乘法实现">矩阵乘法实现</a></li>
        <li><a href="#改写快速幂类型">改写快速幂类型</a></li>
        <li><a href="#根据-fib-数列封装">根据 Fib 数列封装</a></li>
        <li><a href="#简单的单元测试">简单的单元测试</a></li>
        <li><a href="#结尾">结尾</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>矩阵快速幂</h1><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part2/ch01/3-matrix-quick-pow/title.png" alt="题头"></p>
<h2 id="回顾">回顾</h2>
<p>在上一篇文章中，我们对快速幂算法进行了如下的分析：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qpow</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m) {
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> x <span style="color:#f92672">%</span> m;
        x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> x <span style="color:#f92672">%</span> m;
        n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> qpow(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">997</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> qpow(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">997</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 100
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ol>
<li>我们的快速幂算法其实并没有真正的优化乘法效率，而是通过二进制拆分，从而优化了乘法运算的次数，具体的表现就是 <code>x *= x</code> 来扩大乘子的基数；</li>
<li>在计算 <code>res</code> 的时候，<code>res *= x</code> 仍旧是一个累乘的过程，唯一的变化就是 <code>x</code> 在由于 <code>x *= x</code> 逐渐变化。这两个式子结合起来，其实就是 <code>res</code> 不断的去累乘多个 <code>x</code> 。</li>
</ol>
<p>其中的关键就是快速幂其实没有<strong>真正优化乘法的效率，而是优化了乘法运算的次数</strong>。</p>
<p>我们换一个角度来想，<strong>如果有这么一种东西，它也支持乘法和幂运算，同样也拥有像数的乘法一样的规律，是不是也可以进行快速幂的优化</strong>？</p>
<h2 id="斐波那契万物之源">斐波那契，万物之源</h2>
<p>看到这个小标题是不是一脸蒙圈？</p>
<p>为什么快速幂会与斐波那契有关？听我来慢慢道来。</p>
<p>我们都知道斐波那契的递推公式：</p>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \[
Fib(n)=Fib(n - 1)+Fib(n-2)
\]
</span>

<p>所以 <code>Fib(n)</code> 和 <code>Fib(n - 1)</code> 是存在一定关系的。我们通过构造一个多项式，来找出关系：</p>


<span class="katex">
  \[
\begin{aligned}
& f(n)&=f(n-1)&+f(n-2) \\ 
& f(n - 1)&= f(n-1)
&\end{aligned}
\]
</span>

<p>我们讲 <code>Fib(n - 1)</code> 也写入多项式方程中，目的是为了凑足一个多项式，从而将右式中只含有 <code>f(n - 1)</code> 和 <code>f(n - 2)</code> 。</p>
<p>我们把右边的 <code>f(n - 1)</code> 及 <code>f(n - 2)</code> 看做 <code>x1</code> 和 <code>x2</code> ，左边的 <code>f(n)</code> 和 <code>f(n - 1)</code> 看做 <code>y1</code> 和 <code>y2</code> ，得到下式：</p>


<span class="katex">
  \[
\begin{aligned}& y_1=&x_1&+x_2 \\ & y_2= &x_1&\end{aligned} 
\]
</span>

<p>看到这个你是否想起了有一门叫做《线性代数》的课程，当遇到一个齐次线性方程组时，我们可以通过 <strong><code>系数矩阵 * N 维向量</code></strong> 来表示，即：</p>


<span class="katex">
  \[
A·X=B
\]
</span>

<p>这里我们将上式通过矩阵方程来表示：</p>


<span class="katex">
  \[
\begin{bmatrix}y_1\\y_2\end{bmatrix}=\begin{bmatrix}1&1\\ 1&0\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}
\]
</span>



<span class="katex">
  \[
\begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}=\begin{bmatrix}1&1\\ 1&0\end{bmatrix}\begin{bmatrix}f(n-1)\\f(n-2)\end{bmatrix}
\]
</span>

<p>设

<span class="katex">
  \(\begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}\)
</span>
为

<span class="katex">
  \(F(n)\)
</span>
 ，则

<span class="katex">
  \( F(n)=\begin{bmatrix}1&1\\ 1&0\end{bmatrix}·F(n-1)
\)
</span>
</p>
<p>这里我们把矩阵可以当成一个常数来看，其实这就是一个“等比数列”的地推公式，其“公比”就是那个零一矩阵！</p>
<p>所以我们可以得到：</p>


<span class="katex">
  \[
\begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}=\begin{bmatrix}1&1\\ 1&0\end{bmatrix}^{n-1}\begin{bmatrix}f(1)\\f(0)\end{bmatrix}
\]
</span>

<p>所以最终，我们将其转换成了一个求解矩阵幂运算的通项公式。</p>
<h2 id="矩阵乘法实现">矩阵乘法实现</h2>
<p>以下是矩阵乘法的规律：</p>


<span class="katex">
  \[
A = \begin{bmatrix}a_{1, 1} & a_{1, 2} & a_{1,3}\\a_{2, 1} & a_{2, 2} & a_{2,3}\end{bmatrix}
\]
</span>



<span class="katex">
  \[
B = \begin{bmatrix}b_{1, 1} & b_{1, 2} \\b_{2, 1} & b_{2, 2} \\ b_{3, 1} & b_{3, 2}\end{bmatrix}
\]
</span>



<span class="katex">
  \(
C=A·B=\begin{bmatrix}a_{1,1}b_{1, 1}+a_{1, 2}b{_{2, 1}+a_{1,3}b_{3, 1}} & a_{1,1}b_{1, 2}+a_{1, 2}b{_{2, 2}+a_{1,3}b_{3, 2}} \\a_{2,1}b_{1, 1}+a_{2, 2}b{_{2, 1}+a_{2,3}b_{3, 1}} & a_{2,1}b_{1, 2}+a_{2, 2}b{_{2, 2}+a_{2,3}b_{3, 2}} \end{bmatrix}
\)
</span>

<p>根据 <code>n * m</code> 和 <code>m * n</code> 矩阵的规律，我们来写一个矩阵乘法的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define N 2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">matrix</span> {
    <span style="color:#66d9ef">int</span> m[N][N];
    matrix() {
        memset(m, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(m));
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">prt</span>();
};

matrix <span style="color:#66d9ef">operator</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> matrix a, <span style="color:#66d9ef">const</span> matrix b) {
    matrix ans;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> j) {
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> k) {
                ans.m[i][j] <span style="color:#f92672">+=</span> a.m[i][k] <span style="color:#f92672">*</span> b.m[k][j];
            }
        }
    }
    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#75715e">// 打印测试代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> matrix<span style="color:#f92672">::</span>prt() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> j) {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">-&gt;</span> m[i][j] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}
</code></pre></div><h2 id="改写快速幂类型">改写快速幂类型</h2>
<p>既然我们已经对矩阵的 <code>matrix</code> 的结构体做了乘法符号重载，那么我们的快速幂算法实现直接对类型做修改即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">matrix <span style="color:#a6e22e">qpow</span>(matrix x, <span style="color:#66d9ef">int</span> n) {
    matrix res;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        res.m[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">while</span> (n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> x;
        x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> x;
        n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}
</code></pre></div><h2 id="根据-fib-数列封装">根据 Fib 数列封装</h2>
<p>上文我们推导出了斐波那契的矩阵通项公式：</p>


<span class="katex">
  \[
\begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}=\begin{bmatrix}1&1\\ 1&0\end{bmatrix}^{n-1}\begin{bmatrix}f(1)\\f(0)\end{bmatrix}
\]
</span>

<p>然后我们将 <code>f(1) = 1</code> 和 <code>f(0) = 0</code> 带入，形成 <code>base</code> 矩阵。在对左边的零一矩阵做 <code>n - 1</code> 的幂运算，乘以 <code>base</code> 矩阵，返回结果矩阵的 <code>res[0][0]</code> 就是我们要求的 <code>Fib[n]</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n) {
    matrix a;
    a.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a.m[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    matrix base;
    base.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    matrix ans <span style="color:#f92672">=</span> qpow(a, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">*</span> base;

    <span style="color:#66d9ef">return</span> ans.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
}
</code></pre></div><h2 id="简单的单元测试">简单的单元测试</h2>
<p>我们对矩阵快速幂求解斐波那契数列来做一个简单的单元测试，来查看是否满足斐波那契数列的规律。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">#define N 2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">matrix</span> {
    <span style="color:#66d9ef">int</span> m[N][N];
    matrix() {
        memset(m, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(m));
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">prt</span>();
};

<span style="color:#66d9ef">void</span> matrix<span style="color:#f92672">::</span>prt() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> j) {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">-&gt;</span> m[i][j] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}

matrix <span style="color:#66d9ef">operator</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> matrix a, <span style="color:#66d9ef">const</span> matrix b) {
    matrix ans;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> j) {
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> k) {
                ans.m[i][j] <span style="color:#f92672">+=</span> a.m[i][k] <span style="color:#f92672">*</span> b.m[k][j];
            }
        }
    }
    <span style="color:#66d9ef">return</span> ans;
}

matrix <span style="color:#a6e22e">qpow</span>(matrix x, <span style="color:#66d9ef">int</span> n) {
    matrix res;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span> i) {
        res.m[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">while</span> (n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> x;
        x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> x;
        n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n) {
    matrix a;
    a.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a.m[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    matrix base;
    base.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    matrix ans <span style="color:#f92672">=</span> qpow(a, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">*</span> base;

    <span style="color:#66d9ef">return</span> ans.m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 5
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fib(<span style="color:#ae81ff">7</span>) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 13
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="结尾">结尾</h2>
<p>好了这篇文章你已经学会了矩阵快速幂。可能你会觉得很少有场景会使用到这个。这个我说一句实话是这样，只有在一些特殊的递推公式中才能通过矩阵相乘的方式找到通项公式。后面我会总结一下有哪些常见的递推公式可以使用矩阵快速幂来求得通项公式。</p>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#回顾">回顾</a></li>
        <li><a href="#斐波那契万物之源">斐波那契，万物之源</a></li>
        <li><a href="#矩阵乘法实现">矩阵乘法实现</a></li>
        <li><a href="#改写快速幂类型">改写快速幂类型</a></li>
        <li><a href="#根据-fib-数列封装">根据 Fib 数列封装</a></li>
        <li><a href="#简单的单元测试">简单的单元测试</a></li>
        <li><a href="#结尾">结尾</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












