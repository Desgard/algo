<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on 一瓜算法小册</title>
    <link>https://www.desgard.com/algo/docs/</link>
    <description>Recent content in Docs on 一瓜算法小册</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    
	<atom:link href="https://www.desgard.com/algo/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://www.desgard.com/algo/docs/part2/ch04/1-binary-search-one/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch04/1-binary-search-one/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.desgard.com/algo/docs/part2/ch04/2-binary-search-two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch04/2-binary-search-two/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Edmond-Karp 最大流算法详解</title>
      <link>https://www.desgard.com/algo/docs/part4/ch03/4-edmond-karp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part4/ch03/4-edmond-karp/</guid>
      <description>知识梳理  在「初识最大流问题」中，我们了解了什么是流网络模型、什么是最大流问题、以及在流网络中 的增广路（Augmenting Path）概念； 在「Ford-Fulkerson 最大流求解方法」中，我们学习了 Ford-Fulkerson 的最大流问题求解方法和思路：不断的深度优先搜索，直到没有增广路为止则获得最大流； 在「二分匹配的最大流思维」中，通过增加超级源和超级汇来修改二分图，从而将二分匹配问题转换成了最大流问题，最后通过 Ford-Fulkerson 方法解决。  以上三篇先导文章都是在认识和使用最大流这种问题模型，从而进行一些算法思考。但是我们始终没有关心 Ford-Fulkerson 方法的时间复杂度问题。
这篇文章会讲述一个求解最大流问题的 EK 算法，从而优化在某些场景下最大流问题的求解效率。
Ford-Fulkerson 方法有什么问题？ 我们知道，在之前讨论的图中，根据 Ford-Fulkerson 方法，我们采用深度优先搜索（下文简称 DFS），不断的去寻找查询增广路，从而增加超级汇点的流量。先来复习一下 Ford-Fulkerson 方法的算法流程：
 使用 DFS 搜索 出一条增广路； 在这条路径中所有的边的容量减去这条增广路的流量 f，并建立容量为 f 的反向边； 返回操作一，直到没有增广路；  在这个算法流程中，为将 “使用 DFS” 进行了加粗，你一定察觉到一些端倪。我们来从这个角度来思考一下：
假设有一个网络流如上图所示，我们可以一眼看出最大流是 99。但是在我们代码中使用 Fold-Fulkerson 算法进行查找增广路的过程中，由于根据标号进行搜索，所以一定会先找到 S → A → C → &amp;hellip;. → D → E → T 这条增广路。于是我们就浪费了很多开销。
其实我们在这个问题中，只要找到 S → B → E → T 这条增广路，就可以将 T 的入度达到满流状态，后续也就直接结束了。</description>
    </item>
    
    <item>
      <title>Ford-Fulkerson 最大流求解方法</title>
      <link>https://www.desgard.com/algo/docs/part4/ch03/2-ford-fulkerson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part4/ch03/2-ford-fulkerson/</guid>
      <description>在上一节《初识最大流问题》中，已经讲到了网络流中的一个经典问题 - 最大流问题。同上一篇的方式一样，这篇文章你要带着以下两个问题来阅读：
 怎样搜索到一条增广路？ 如何利用搜索到的增广路求解最大流问题？ Ford-Fulkerson 算法求最大流的原理是什么？  如何求得最大流 我们继续引用上文的例子：
 假设有这么一个例子，这次 2019-nCoV 疫情让口罩变成了稀缺资源。所以，全国各地都在为武汉捐献物资。假设现在因为种种原因，我们只能通过地面线路来运输口罩物资，并且每一条线路是有流量限制的。假设不考虑运输速度，并且源点 S （杭州）的口罩物资产量是足够多的，我们需要求解汇点 T（武汉）在不计速度的情况下能收到多少物资？
 首先我们拍脑袋来自己探索一个算法，计算最大流。
我们的目标是找到增广路，所以我们制定一个策略：通过 DFS 深度优先搜索，来检索一条增光路，然后计算从 S 到 T 的最大流量，并在所有的边流量容量中将其扣除。反复按照这种操作，来迭代我们每次扣除之后的残余网络，最后无法再找到增广路则停止搜索，求得我们的“最大流”。
我们来做一个动图来描述一下这个过程：
您的浏览器不支持 video 标签。  这个动图中描述的算法包括以下三步：
 搜索出一条增广路； 在这条路径中所有的边容量减去这条增广路的流量，如果容量为 0 则拆边； 返回操作一，如果没有增广路则得到答案。  在这道例题中，我负责任的告诉你，答案确实是最大流 23。但是求解的过程是错的！ 为什么会造成过程是错的，但是答案是对的的情况？原因是因为这个流网络的最大流刚好是我们这种做法所得到的答案。那正确的解法应该是怎样的？我们在来看一个图：
我们按照上文的方法来求解一下最大流。
我们通过上述的三步流程进行演算，最终获得的残余网络如上，求得最大流是 10。
但是我在这里再次负责的告诉你，**这个结果是不正确的！**理由如下：
按照这种方式来处理流量，可以获得最大流 11 的答案，这是更优的结果。由此我们证明了上述我们自己构造的算法是有问题的。可是问题出在哪呢？我们对比一下两张图的流量差：
通过对比流量差，我们 发现其中 1 → 2 会通过将流量推回这种操作，从而得到新的流 。为什么要这么做呢？其实原因就是 因为对一条增广路不一定输入这条增广路的上限流量就能保证全局的最大流量 。再提高一个维度来看我们之前的思路，其实一直是“贪心”思想在引导我们加流和拆边操作，但是贪心并不能获得全局最大流量，这也是之前动态规划能够解决贪心对于全局最优解无法实现的问题 。
既然我们无法得知如何取得全局最优解，有一种思路就是，继续增加可能情况。具体怎么加，其实只要对上面错误算法增加一个操作就可以：在第 2 步中，在边权减去流量之后，并对这条边再做一条反向边，并且容量变成对应消耗流量的相反数 。接着用图来解释：
通过上述操作，我们又多找出了一条增广路（即图中红色的那条路），并且为 T 多增加了 1 个单位的流量，如此求得了最后的答案是 11。</description>
    </item>
    
    <item>
      <title>RMQ（Range Maximum Query) 问题</title>
      <link>https://www.desgard.com/algo/docs/part2/ch03/1-range-max-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch03/1-range-max-query/</guid>
      <description>今天的算法可能有点难，但是如果我们只需要会使用 RMQ 问题的 ST 算法模板，这种程度就已经可以了！因为 RMQ 问题除了最优解的 ST 算法，剩下的都是高级数据结构的应用，例如：线段树、树状数组、Splay、Treap 甚至是主席树（额，我什么都没有暗示，业界就是这个名字）。好了今天我们从两个角度来解决这个问题。ST 算法和线段树。当然如果你对高级数据结构感兴趣，我也会在以后的文章中更新这个系列。
 注意，学 RMQ 问题与图论没有直接关系，而是 Tarjan 算法中其中的一个重要步骤之一。再次验证了高级算法都是由基础的问题排列组合而来！🧐
这篇文章我们只讲 RMQ 问题以及 RMQ 的最优解法 ST 算法。
引子 RMQ 的英文是 Range Maximum(Minimum) Query，翻译过来其实就是区间求最值的意思。问题描述：对于长度为 n 的数列 A，回答若干询问   \(RMQ(A, i, j)(i, j ，返回数列A中下标在 [i, j] 里的最小(大）值。
在这个问题中，我们需要关注的是查询操作，查询可能是海量的，所以如果我们对数据进行快速的预处理，然后在外面处理后的数据结构中进行快速查询，其实就是最理想的状态。
另外，注意是“在给定的区间内”，那么则说明区间在后续的查询时没有变化。所以我们可以理解成在区间确定后，我们其实已经拿到了所有查询情况的答案！对于这种对给定范围内求值的算法，我们对其归类为离线算法。（当然对应的还有在线算 法，后面讲 Tarjan 算法时我们再详谈）
我们先来尝试下暴力：
nums = [3, 2, 4, 5, 6, 8, 1, 2, 9, 7] def query(l, r): res = nums[0] for i in range(l, r + 1): res = max(res, nums[i]) return res 我们发现每一次查询都是一个 \(O(n)\)  的操作，在海量的查询面前，效率就十分低下了。或许你觉得 \(O(n)\)  还能接受？但是人总是喜新厌旧、择优选择的 🙄 。</description>
    </item>
    
    <item>
      <title>二分匹配的最大流思维</title>
      <link>https://www.desgard.com/algo/docs/part4/ch03/3-perfect-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part4/ch03/3-perfect-matching/</guid>
      <description>在之前的两篇文章中，我们讲述了「最大流问题」和「Ford-Fulkerson 最大流求解方法」，当然在阅读这篇文章之前，我需要你有以上两篇文章的基础，请在阅读上面两篇文章后再来进行阅读。这篇文章我们来讲述一个二分图匹配问题。并且将这个问题转化为最大流问题模型来解决。
为了引出二分图匹配问题，我们首先给出一个实际问题的例子：
计算机 CPU 指派问题 在我的 N 核计算机上有 K 个任务。每个任务在工作时都得霸占 CPU 一个完整的核心，并且每个 CPU 核心不是所有任务都能处理，只能处理其中几种任务。我们的问题是在一次处理过程中，最多能够处理的任务数是多少？
上图中我描述了一组样例，在这组样例中 Task A 只能有 CPU X 和 CPU Y 来处理，Task B 只能由 CPU X 和 CPU Z 来处理，而 Task C 只能有 CPU Y 来处理。
问题抽象与二分图最大匹配 其实上面对于样例的描述我们已经可以画出一个有向图了。我们将 Task 和 CPU 都转换成图节点：
我们发现，这个图他可以分成左右两部分，并且左边这些节点相互之间没有相连的边，同样的右边节点也没有相连的边，所有的边都是左右两个部分之间的连接，对于这种特点的图，在图论中有一个专有的名词，二分图。
而对于这个问题，我们需要求最多有多少个任务可以被处理，也就是说根据关系找到一种 Task 和 CPU 的配对方式，使得配对数量达到最大。这种二分图求最大匹配数量的问题，我们称之为二分图最大匹配问题。
思考和转化问题 使用结果反向启发 我们可以考虑一种上方样例中的最大匹配方案，如下图所示就是一种情况：
我们观察一下上面的答案，其实是删除了 A → Y 和 B → X 这两条边。有没有感觉这种删除边的操作我们之前也处理过呢？这里我们从最终的结果出发来启发你的思维，如果你没有发现什么玄机，我们再来做一个新的变化。
赋权值量化图 第二种变化，我们对于原图的任意一条边增加权值为 1 。
变化之后，我们只看左右两个部分，此时思考问题的角度就变成了从左边的节点集合到右边节点集合 最多可以保留几条边？换句话说，也就是从左到右流入的最大权值是多少？当然不是任意一条边都能保留，因为每一节点只能有一个出度和一个入度，这个条件也就确保了我们求得的结果是匹配数。
既然我们需要保证左边集合中，每一个节点有且只有一个出度，而右边的节点有且只有一个入度，那么我们不妨将这个题目再次进行转换，我们将边权值定义为流量容量，且节点也增加权值，且定义为当前节点的流量值。</description>
    </item>
    
    <item>
      <title>初识最大流问题</title>
      <link>https://www.desgard.com/algo/docs/part4/ch03/1-maximum-flow-basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part4/ch03/1-maximum-flow-basic/</guid>
      <description>在阅读之前先来提出几个问题。如果这些问题你都知道答案那就可以直接跳过，期待下一篇文章了：
 什么是网络流模型？ 网络流有哪些经典问题？ 哪些问题能转化成网络流问题？  这篇文章会用一个描述的方式来先认识这些概念问题，而代替很多书上的符号标记。
流网络与最大流问题 首先网络流问题都是建立在流网络上的。这一点不要弄混，所谓流网络首先它是一个有向图，并且图中每条边都有一个非负的容量值。这个容量值我们暂时可以理解成边的权，但是这个权有着它自身的含义。我们来针对流网路举一个例子：
 假设有这么一个例子，这次 2019-nCoV 疫情让口罩变成了稀缺资源。所以，全国各地都在为武汉捐献物资。假设现在因为种种原因，我们只能通过地面线路来运输口罩物资，并且每一条线路是有流量限制的。假设不考虑运输速度，并且源点 S （杭州）的口罩物资产量是足够多的，我们需要求解汇点 T（武汉）在不计速度的情况下能收到多少物资？
 上面的流网络可能我们很难一眼看出答案，那么我们先简化一下场景。我们删几条边来看下这个问题：
对于这个流网络，我们可以轻松的获得汇点 T 的最大流量。
因为在这个图中，只有两条路径，本别是 S → A → B → T 和 S → C → D → T 两条路径来输送流量，前者最大流量是 12 ，后者是 4，所以最大流量总和是 16。
这其实就是流网络的一个经典问题模型 —— 最大流问题（Maximum-Flow Problem）。
网络流问题的一些关键概念 在上述场景中，我们讲述了最大流问题是在研究什么样的问题。接下来，我们来定义一些网络流问题当中的一些关键概念。这些概念有助于理解以后学习网络流中出现的各种名词。
什么是增广路？ 首先我们来说什么是增广（Augmenting）？在最大流问题中，我们每次找的一条可以增加汇点流量的路径，即在网络中找出一条可以到汇点 T 的道路，并且求出这条道路所有边剩余容量的最小值 d，并在上所有边的流量都加上这个 d，这个过程就是增广。而增广路（Augmenting Path）就是这条可以给 T 带来更多流量的路径。
比如上图中，S → A → B → T 和 S → C → D → T 就是两条增广路。</description>
    </item>
    
    <item>
      <title>加速幂运算</title>
      <link>https://www.desgard.com/algo/docs/part2/ch01/1-quick-pow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch01/1-quick-pow/</guid>
      <description>幂运算是我们平时写代码的时候最常用的运算之一。根据幂运算的定义我们可以知道，如果我们要求 x 的 N 次幂，那么想当然的就会写出一个 N 次的循环，然后累乘得到结果。所以我们要求幂运算的复杂度仍旧是   \(O_{(N)}\)  ?
那么有没有一种更快的方法呢？
这里给出一种在计算机领域常用的快速幂算法，又叫蒙哥马利幂（Montgomery reduction）算法，将 \(O_{(N)}\)  降为 \(O_{(logN)}\)  。
我通过例子来讲解这个优化过程：
假设我们要算 x 的 n 次幂，使用累乘来编写代码：
res = 1 for i in range(n): res *= x 好的，我们已经完成了 \(O_{(N)}\)  的解法。
二进制拆分 为了优化这个算法，我们接下来进行数学推导：
我们继续思考当 N = 10 这个具体场景，我们可以把 10 写成二进制来表示 1010(BIN)，然后我们模拟一次二进制转十进制的过程（复习一下大学知识）：
\[ 10 = 2^3 \times \underline{1} + 2^2 \times \underline{0} + 2^1 \times \underline{1} + 2^0 \times \underline{0} \]  我用下划线把二进制的 1010 标识出来，这样大家就可以发现二进制和十进制转换时的代数式规律。</description>
    </item>
    
    <item>
      <title>快速幂取模算法</title>
      <link>https://www.desgard.com/algo/docs/part2/ch01/2-quick-pow-mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch01/2-quick-pow-mod/</guid>
      <description>上一篇文章我们讲了如何将幂运算优化到   \(O(logN)\)  的方法。这一篇来研究一下，快速幂算法与取模运算是如何结合的。
取余和取模 首先我们要知道在编程语言中有 % 这么一个操作符，在各大编程书中称之为“取余运算”。在程序设计和抽象数学领域，我们管这个操作叫做：取模运算。
下面以整型 a 和 b 两个变量举例，在我们常说的取余运算中，其算法会分成以下的两个步骤：
 求整数商：c = a / b 求余数：r = a - c * b  取模与取余不同在于第一步，求余在整除的时候是往 0 方向逼近，而取模是往负无穷方向逼急。这样就造成了在对负数进行取模运算的差异。所以在计算 -7 % 4 的时候，求余运算的结果是 -3，而取模运算是 1。
/// 第一步：求整数商 // 求余运算 -7 / 4 = -1 (逼近 0 ) // 求模运算 -7 / 4 = -2 (逼近负无穷) /// 第二步： // 求余运算 -7 - -1 * 4 = -7 + 4 = -3 // 求模运算 -7 - -2 * 4 = -7 + 8 = 1 当然，逼近方向其实不影响其他的运算规律，因为任意的 a % b，对于给定的 a 和 b ，计算结果一定是一个确定的值。所以我们只需了解这两种计算的区别就可以。</description>
    </item>
    
    <item>
      <title>快速素数筛法</title>
      <link>https://www.desgard.com/algo/docs/part2/ch02/1-eratos-sive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch02/1-eratos-sive/</guid>
      <description>本文的内容实用而且简单！素数问题是从来都是数学家热衷探索的领域，也是程序设计竞赛和 LC 中，解决数论相关问题的基础，下面本文介绍如何更科学地筛素数和一些相关的小知识。
首先从定义来说， **素数，指整数在一个大于 1 的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。**那么首先我们可以根据定义来写出我们的最暴力求解素数的程序
暴力统计素数 假设有 n 个数，我们的方法很简单，判断每个数是否有其他因子，如果有则不是素数，时间复杂度为 O(nlogn)。
我们以的题目 《LeetCode-204 计数质数》 为例，题目描述：
统计所有小于非负整数 n 的质数的数量。
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
 我们可以写出如下程序：
class Solution: def countPrimes(self, n: int) -&amp;gt; int: ans = 0 for i in range (2, n): flag = True # 只需要检查小于等于sqrt(n)的因数就可以了,因为大于的那部分一定对应着一个小于sqrt(n)的因数 for j in range(2, int(math.sqrt(i)) + 1): if 0 == i % j: flag = False break if flag: ans += 1 return ans 功能上来说，我们的已经完全实现对素数进行计数，但是提交结果超出时间限制。所以接下来我们要改进一下算法。</description>
    </item>
    
    <item>
      <title>扩展欧几里得算法</title>
      <link>https://www.desgard.com/algo/docs/part2/ch02/3-ext-euclidean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch02/3-ext-euclidean/</guid>
      <description>一道头条的笔试题 上个月在脉脉上看到一道头条校招的笔试题，看评论说是“地狱难度”的，我们通过这道题来延伸说一下。先来看下这题的题面：
有一台用电容组成的计算器，其中每个电容组件都有一个最大容量值（正整数）。
对于单个电容，有如下操作指令：
指令1：放电操作-把该电容当前电量值清零；
指令2：充电操作-把该电容当前电量补充到最大容量值；
指令3：转移操作-从电容 A 中尽可能多的将电量转移到电容 B ，转移不会有电量损失，如果能够充满 B 的最大容量，那剩余的电量仍然会留在 A 中。
现在已知有两个电容，其最大容量分别为 a 和 b，其初始状态都是电量值为 0，希望通过一些列的操作可以使其中某个电容（无所谓哪一个）中的电量值等于 c （c也是正整数），这一些列操作所用的最少指令条数记为 M，如果无论如何操作，都不可能完成，则定义此时 M= 0。
显然对于每一组确定的 a，b，c，一定会有一个 M 与之对应。
 这里需要输入的是 a、b、c ，给出两个样例，例如 a = 3, b = 4, c = 2 ，则最少需要 4 个指令完成。解释：设最大容量为 3 的是 A 号电容，另一个是 B 号电容，对应的操作是 （充电 A）=&amp;gt; （转移 A -&amp;gt; B） =&amp;gt; （充电 A）=&amp;gt; （转移 A -&amp;gt; B） ，这样 A 就是目标的 2 电量。第二个样例 a = 2, b = 3, c = 4，由于 a 和 b 都无法到大目标电量 4，所以输出 0 代表无解。</description>
    </item>
    
    <item>
      <title>欧几里得算法</title>
      <link>https://www.desgard.com/algo/docs/part2/ch02/2-euclidean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch02/2-euclidean/</guid>
      <description>什么是欧几里得算法？欧几里得算法是为了解决 GCD 问题，这里的 GCD 是指 Greatest Common Divisor 即最大公约数，而不是 iOS 中的 Grand Central Dispatch 🤣 。所以这篇分享是关于算法的。
欧几里得算法（GCD） 求 GCD 在数论中公认的最常用算法即为欧几里得算法，也就是我们在高中时学到的辗转相除法。
欧几里得算法的基本原理用一句话就可以说清楚：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数，即   \(gcd(a, b) = gcd(b, a\ mod\ b)\)  。
为什么可以这么求呢，这里可以简单证明一下：
假设 \(a, b (a  b)\)  两个数的一个公约数是 \(t\)  ，则有
\[ a=n\times t \\ b=m\times t \]  因为 \(a  b\)  ，设 \(a = k × b + r\)  ，即 \(r = a\ mod\ b\)  ，将 \(a,b\)  代入展开可得：</description>
    </item>
    
    <item>
      <title>用线段树再看 RMQ 问题</title>
      <link>https://www.desgard.com/algo/docs/part3/ch02/1-segment-tree-rmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part3/ch02/1-segment-tree-rmq/</guid>
      <description>GGTalk 播客
[28:30] 磊子：国内某特别爱招聘的大厂问过这么一道题：一个数组，要求得任意一个区间段内最大的数是多少。如果大家了解的话，就知道这题其实在考线段树&amp;hellip;.
 其实 RMQ (Range Minimum/Maximum Query) 问题（又称区间最值问题）之前的文章中也有讲述，在《RMQ 问题》 小节中，通过 ST 的二倍增 + 动态规划的思路，以   \(O(nlogn)\)  预处理以及查询 \(O(1)\)  复杂度下解决了这个问题。
也许你会想，在数组中直接遍历一下不就完了了吗，为什么要费这么多事情来做？直接遍历查找一遍也就是 \(O(n)\)  的复杂度？是的，其实背景是这样，因为我们需要做 \(K\)  次查询，这个 \(K\)  的上限很大，你可以理解成这个背景是在海量查询之下。
所以我们的出发点是通过一种优质的数据结构，将查询复杂度降低成 \(O(logn)\)  或者 \(O(1)\)  。由于查询次数是强需求，不是算法层面上可以优化的，所以在查询上的效率是我们主要解决的问题。
为了解决查询问题，这一篇文章我们引入 线段树（Binary Indexed Tree） 来优化 RMQ 问题的查询操作复杂度。
线段树的概念 我们如何理解线段树的定义呢？我们先抛开 RMQ 场景，先引入一个区间求和问题。
 题目：给你一个数组 \(A\)  ，它有 \(K\)  次查询，每次查询都给你 \(a\)  和 \(b\)  两个值，且 \(a ，每次查询输出一个结果，代表 \(A[a] + A[a + 1] + .</description>
    </item>
    
    <item>
      <title>矩阵快速幂</title>
      <link>https://www.desgard.com/algo/docs/part2/ch01/3-matrix-quick-pow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch01/3-matrix-quick-pow/</guid>
      <description>回顾 在上一篇文章中，我们对快速幂算法进行了如下的分析：
int qpow(int x, int n, int m) { int res = 1; while (n) { if (n &amp;amp; 1) res = res * x % m; x = x * x % m; n &amp;gt;&amp;gt;= 1; } return res; } int main() { cout &amp;lt;&amp;lt; qpow(10, 3, 997) &amp;lt;&amp;lt; endl; // 3  cout &amp;lt;&amp;lt; qpow(10, 2, 997) &amp;lt;&amp;lt; endl; // 100  return 0; }  我们的快速幂算法其实并没有真正的优化乘法效率，而是通过二进制拆分，从而优化了乘法运算的次数，具体的表现就是 x *= x 来扩大乘子的基数； 在计算 res 的时候，res *= x 仍旧是一个累乘的过程，唯一的变化就是 x 在由于 x *= x 逐渐变化。这两个式子结合起来，其实就是 res 不断的去累乘多个 x 。  其中的关键就是快速幂其实没有真正优化乘法的效率，而是优化了乘法运算的次数。</description>
    </item>
    
    <item>
      <title>矩阵的递推关系分析</title>
      <link>https://www.desgard.com/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/</guid>
      <description>这篇文章可能会有一些难度，但是所有的预备基础都在前三篇文章中：
 快速幂 快速幂取模 矩阵快速幂  引子 数字是我们在编程中最常接触的元数据。无论是在业务还是刷题，多半部分都是数字的运算，其次是字符串，再次是布尔。
虽然矩阵也是由数字构成的，但是矩阵往往是描述一个多元方程组的元数据。在业务中很少接触方程的运算，所以自然而然的《线性代数》这门重要但又不重要的学科在工作后说忘就忘。
所以，这篇文章可能对于你工作甚至是面试都不一定有直接的收益，如果考虑业务能力和面试 ROI，也就不需要再浪费时间阅读。
斐波那契的矩阵快速幂归纳 通过之前的文章，我们已经推出了斐波那契数列通过矩阵来表示的递推公式：
  \[ \begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\ 1&amp;0\end{bmatrix}\begin{bmatrix}f(n-1)\\f(n-2)\end{bmatrix} \]  再来分析一下我们将表达式 \(f(n) = f(n - 1) + f(n - 2)\)  转化成矩阵形式的递推公式到底目的是什么？为什么只要这么做，就可以带来优化算法时间复杂度的收益？
从这三个点来思考：
 关系变量减少：原来是 \(f(n) = f(n - 1) + f(n - 2)\)  ，通过矩阵表示后，降为 \(A(n - 1)·C = A(n)\)  。 恰好通过矩阵形式表示后变成了一个等比数列的形式，这样就可以求出通向公式。而通向公式又是一个幂指数的运算，所以我们联想到了快速幂算法。  \(N · N\)  方阵的矩阵乘法，遵循结合律。  归纳问题 思考点 3 是矩阵的规律，这个我们就不再细究。但是思考点 1 和 2，可以为我们延伸出以下的几种场景：
增加系数 重点在于如果我们遇到一个表达式 \(f(x)\)  ，只要我们能得到它的递推公式，将其转换成 \(A(n - 1)·C = A(n)\)  的形式其实就可以沿用斐波那契数列矩阵快速幂的整体思路拉求解。既然这样，我们就再次从斐波那契数列入手，先对 \(f(n - 1)\)  和 \(f(n - 2)\)  加系数：</description>
    </item>
    
    <item>
      <title>线段树区间更新操作</title>
      <link>https://www.desgard.com/algo/docs/part3/ch02/3-segment-tree-range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part3/ch02/3-segment-tree-range/</guid>
      <description>在之前的文章中，我们已经学习了如何使用线段树来做一些常规的区间操作：如何建树、单点更新、区间查询。这些操作通过线段树这种数据结构的特点，将单点更新和区间查询的复杂度都统一到   \(O(logn)\)  ，在海量查询场景下的开销也降低了很多。
那么关于线段树的讨论就到此为止了吗？其实并不是。我们学到的还只是冰山一角。这篇文章，我们来讨论一下如何通过线段树来实现区间更新。区间更新的操作在这里指的是对某一个范围的数进行增加或减少同一个常数的操作。例如数组 [2, 3, 4, 5, 6] ，对其下标 [0, 2] 进行区间更新都增加 10 ，则数组会变成 [12, 13, 14, 5, 6] 。
以下对于线段树的讨论全部以区间和场景为准。
单点更新遍历 当我们讨论区间更新的时候，肯定已经有读者开始思考：只要我们遍历一下区间的每一个值，执行单点更新不就可以了？
从结果上来看，这么做完全可以。从复杂度上来看，以 \(O(nlogn)\)  复杂度执行一次长度为 \(n\)  的区间更新。
我们回过头来看我们引出线段树目的是什么？为了实现常数复杂度时间构造和对数复杂度的操作。那么，我们有没有方式将区间更新操作通过对数复杂度 \(O(logn)\)  时间来更新一个区间的数值呢？
考虑查询时候的行为 上文介绍的 query 操作总结成动图如下（假设我们有下标 [1, 8] 8 个元素构成的区间和线段树，此时我们要查询 [1, 6] 这个区间）：
我们可以发现，其实在每次查询的时候，是不断对当前层级所表示的区间进行二分分治，直到最后每个分块的并集即为待查询区间。
另外线段树还有一个特点：由于我们引入的 push_up 操作，这就会让线段树有这么一个特点：父亲结点是包括子结点的状态。这是一个什么意思呢？拿区间和为例，push_up 是通过子结点数值求和来构造父结点，即：
tree[rt] = tree[rt * 2] + tree[rt * 2 + 1] 由于这个核心操作，我们发现我们描述的线段树是一种下级扩展上级的结构。当查询的时候，如果查询的节点所描述的区间符合要求，则会被计算到结果中。
要确定一个目标，我们的节点更新其实是为了查询到最新的结果。
所以有这么一个思路， 对所有查询范围中最小粒度的节点进行更新，从而就能让所有的查询操作返回最新的情况。什么是范围中最小粒度的节点呢？其实就是要满足两个特点：
 在查询范围中； 尽量在线段树的上层。  增量记录 根据查询自上到下的特点，我们来维护一个增量数组，这个增量数组代表对应的节点待更新的增量。假设我们对上面动图上的线段树进行一个区间更新的操作，将 [3, 6] 这个区间上的所有数字增加 4 。此时我们的增量数组如图所示：</description>
    </item>
    
    <item>
      <title>线段树实战要点</title>
      <link>https://www.desgard.com/algo/docs/part3/ch02/2-segment-tree-combat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.desgard.com/algo/docs/part3/ch02/2-segment-tree-combat/</guid>
      <description>在上一公众号中 《用线段树再看 RMQ 问题》，通过区间和的问题场景，已经学习了线段树的基本结构，以及其单点更新和区间查询的操作。但是在解 《LeetCode-307 区域和检索 - 数组可修改》 这道题目的时候，并不是一帆风顺的。所以这一篇文章我们来讨论一下线段树在做题时会遇到的一些坑。
空间退化问题 在 《LeetCode-307 区域和检索 - 数组可修改》 中，我们会遇到下标索引超出范围的 9/10 的 case。这也就是我们遇到的第一个最直观的坑。
上文我们说过，线段树是一棵 完美二叉树(Perfect Binary Tree)，可是题目中给出的结点个数不一定是   \(2^N\)  次幂个。所以，这就带来了 空间结构退化的问题。
这里我们假设 N = 13 这个情况，然后我们通过之前的线段树代码进行代码实现后其结构变成了这样：
通过上图，我们发现如果我们使用 2N = 26 的数组空间，实际上线段树已经覆盖了下标 31 ，这个场景下我们开 2N 的数组是不够的。
这里直接说结论：我们对线段树的描述数组开 4N 的空间，是绝对够用的。 具体的证明后续文章中单独写。
在谈 RMQ 问题 在第一篇文章中，我们讲了区间和的场景，将最重要的向上更新操作 Push Up 也做了介绍，并且给大家留了一道思考题：如何使用线段树来实现 RMQ 问题。
其实我们只需要修改两个地方：
 在向上更新的时候，重新制定规则 - 父结点是两个子节点的大值； 在查询的时候，将结果取递归搜索的大值；  代码如下：
// 吸取上面的教训，现在我们数组开 4 倍 int tree[maxn &amp;lt;&amp;lt; 2]; void push_up(int rt) { // 父结点是子节点中的最大值  tree[rt] = max(tree[rt &amp;lt;&amp;lt; 1], tree[rt &amp;lt;&amp;lt; 1 | 1]); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) { return tree[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1; int ret = 0; // 修改成递归查找区间最大值当做查询结果  if (L &amp;lt;= m) ret = max(ret, query(L, R, l, m, rt &amp;lt;&amp;lt; 1)); if (R &amp;gt; m) ret = max(ret, query(L, R, m + 1, r, rt &amp;lt;&amp;lt; 1 | 1)); return ret; } 其实 RMQ 线段树并没有对线段树结构有任何改变，仅仅是修改了父子结点间的运算规则。</description>
    </item>
    
  </channel>
</rss>