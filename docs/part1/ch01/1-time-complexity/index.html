<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="时间复杂度估算土法"><meta property="og:title" content="时间复杂度估算土法" />
<meta property="og:description" content="想必大家都知道很多算法书上面的复杂度计算基础的“第一章节”，长到你不想看。但是不看吧又觉得失去了什么。所以这篇文章就来说说这个复杂度有没有什么通俗易懂的土方法来计算。
土法一：执行一行约是一次运算 我们假设计算机运行一行基础代码，就需要进行一次运算。也就是我们常常说的 O(1)。
来写一段从 1 累加到 100 的代码：
s = 0 for i in range(1, 101): s &#43;= i print(s) # 5050 如此要循环 100 次，时间复杂度就是   \(O_{(100)}\)  。如此，我们改变计算上届，将 100 扩大到 n ，这样便会发现使用循环的方法进行累加是一个时间复杂度为 \(O_{(n)}\)  的算法。
我们将累加算法改成等差数列前 n 项求和来计算：
s = (1 &#43; 100) * 100 // 2 # 5050 如此，我们将一个 \(O_{(n)}\)  的算法优化到了 \(O_{(1)}\)  。这种优化无论是对于计算机，还是我们人脑，都可以大幅度的降低运算复杂度。
为什么说高斯是天才，因为他在小学三年级就发现了这个规律，并将一个 \(O_{(n)}\)  的算法优化到了 \(O_{(1)}\)  。
土法二：以经验计算时间 以前我在大学的时候参加 ACM 竞赛有这么一个土方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.desgard.com/algo/docs/part1/ch01/1-time-complexity/" />

<title>时间复杂度估算土法 | 一瓜算法小册</title>
<link rel="icon" href="/algo/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/algo/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA&#43;zb6B2UFjbjUnM=">


<script defer src="/algo/en.search.min.32075440d70fd273d2efb6e0ff5b6e0fc98a3319f4c164e8da82869bcbc7aee1.js" integrity="sha256-MgdUQNcP0nPS77bg/1tuD8mKMxn0wWTo2oKGm8vHruE="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js"></script>


<script src="https://www.gstatic.com/firebasejs/7.9.1/firebase-analytics.js"></script>

<script>
  
  var firebaseConfig = {
    apiKey: "AIzaSyAZeDebssmjx4XyPoVaXqD4KGUlOMtwcx0",
    authDomain: "algo-book.firebaseapp.com",
    databaseURL: "https://algo-book.firebaseio.com",
    projectId: "algo-book",
    storageBucket: "algo-book.appspot.com",
    messagingSenderId: "622768980616",
    appId: "1:622768980616:web:fed8fa42fe59ab711bd53d",
    measurementId: "G-5HQT6KLJEY"
  };
  
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algo"><span>一瓜算法小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/algo/">序章</a></li>
<li>第一部分 做题技巧
<ul>
<li>第一章 巧用复杂度
<ul>
<li><a href="/algo/docs/part1/ch01/1-time-complexity/"class=active>时间复杂度估算土法</a></li>
</ul>
</li>
</ul>
</li>
<li>第二部分 计算机数学思维
<ul>
<li>第一章 快速幂
<ul>
<li><a href="/algo/docs/part2/ch01/1-quick-pow/">加速幂运算</a></li>
<li><a href="/algo/docs/part2/ch01/2-quick-pow-mod/">快速幂取模算法</a></li>
<li><a href="/algo/docs/part2/ch01/3-matrix-quick-pow/">矩阵快速幂</a></li>
<li><a href="/algo/docs/part2/ch01/4-matrix-quick-pow-analysis/">矩阵的递推关系分析</a></li>
</ul>
</li>
<li>第二章 数论
<ul>
<li><a href="/algo/docs/part2/ch02/1-eratos-sive/">快速素数筛法</a></li>
<li><a href="/algo/docs/part2/ch02/2-euclidean/">欧几里得算法</a></li>
<li><a href="/algo/docs/part2/ch02/3-ext-euclidean/">*扩展欧几里得算法</a></li>
</ul>
</li>
<li>第三章 经典模型
<ul>
<li><a href="/algo/docs/part2/ch03/1-range-max-query/">RMQ 问题</a></li>
</ul>
</li>
<li>第四章 二分搜索
<ul>
<li><a href="/algo/docs/part2/ch04/1-binary-search-one/">二分搜索·上</a></li>
</ul>
</li>
</ul>
</li>
<li>第三部分 数据结构
<ul>
<li>第一章 基础数据结构</li>
<li>第二章 区间数据结构
<ul>
<li><a href="/algo/docs/part3/ch02/1-segment-tree-rmq/">用线段树再看 RMQ 问题</a></li>
<li><a href="/algo/docs/part3/ch02/2-segment-tree-combat/">线段树实战要点</a></li>
<li><a href="/algo/docs/part3/ch02/3-segment-tree-range/">线段树区间更新操作</a></li>
</ul>
</li>
<li>第三章 字符串</li>
<li>第四章 排序二叉树</li>
</ul>
</li>
<li>第四部分 图论
<ul>
<li>第一章 图论基础算法</li>
<li>第二章 深度优先的连通性分析</li>
<li>第三章 网络流
<ul>
<li><a href="/algo/docs/part4/ch03/1-maximum-flow-basic/">*初识最大流问题</a></li>
<li><a href="/algo/docs/part4/ch03/2-ford-fulkerson/">*Ford-Fulkerson最大流方法</a></li>
<li><a href="/algo/docs/part4/ch03/3-perfect-matching/">*二分匹配的最大流思维</a></li>
<li><a href="/algo/docs/part4/ch03/4-edmond-karp/">*Edmond-Karp 最大流算法详解</a></li>
</ul>
</li>
<li>第四章 二分图匹配</li>
</ul>
</li>
<li>第五部分 数学建模</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algo/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>时间复杂度估算土法</strong>

  <label for="toc-control">
    <img src="/algo/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#土法一执行一行约是一次运算">土法一：执行一行约是一次运算</a></li>
        <li><a href="#土法二以经验计算时间">土法二：以经验计算时间</a></li>
        <li><a href="#土法三取极限估算复杂度">土法三：取极限估算复杂度</a>
          <ul>
            <li><a href="#1-观察后舍去差距较大的">1. 观察后舍去差距较大的</a></li>
            <li><a href="#2-不确定式两两使用求极限判断等价性">2. 不确定式两两使用求极限，判断等价性</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>时间复杂度估算土法</h1><p><img src="https://raw.githubusercontent.com/Desgard/algo/img/img/part1/time-complexity/title.png" alt="title"></p>
<p>想必大家都知道很多算法书上面的复杂度计算基础的“第一章节”，长到你不想看。但是不看吧又觉得失去了什么。所以这篇文章就来说说这个复杂度有没有什么通俗易懂的土方法来计算。</p>
<h2 id="土法一执行一行约是一次运算">土法一：执行一行约是一次运算</h2>
<p>我们假设计算机运行一行基础代码，就需要进行一次运算。也就是我们常常说的 <code>O(1)</code>。</p>
<p>来写一段从 <code>1</code> 累加到 <code>100</code> 的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">101</span>):
    s <span style="color:#f92672">+=</span> i
<span style="color:#66d9ef">print</span>(s) <span style="color:#75715e"># 5050</span>
</code></pre></div><p>如此要循环 <code>100</code> 次，时间复杂度就是 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<span class="katex">
  \(O_{(100)}\)
</span>
 。如此，我们改变计算上届，将 <code>100</code> 扩大到 <code>n</code> ，这样便会发现使用循环的方法进行累加是一个时间复杂度为 

<span class="katex">
  \(O_{(n)}\)
</span>
 的算法。</p>
<p>我们将累加算法改成等差数列前 <code>n</code> 项求和来计算：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">s <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">100</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># 5050</span>
</code></pre></div><p>如此，我们将一个 

<span class="katex">
  \(O_{(n)}\)
</span>
 的算法优化到了 

<span class="katex">
  \(O_{(1)}\)
</span>
 。这种优化无论是对于计算机，还是我们人脑，都可以大幅度的降低运算复杂度。</p>
<p>为什么说高斯是天才，因为他在小学三年级就发现了这个规律，并将一个 

<span class="katex">
  \(O_{(n)}\)
</span>
  的算法优化到了 

<span class="katex">
  \(O_{(1)}\)
</span>
 。</p>
<h2 id="土法二以经验计算时间">土法二：以经验计算时间</h2>
<p>以前我在大学的时候参加 ACM 竞赛有这么一个土方法：</p>
<p><strong>一般的计算机，在处理 

<span class="katex">
  \(10^7\)
</span>
  计算的时候需要消耗一秒的时间。可以写一个来验证一下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> datetime

tot_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>):
    st <span style="color:#f92672">=</span> datetime<span style="color:#f92672">.</span>datetime<span style="color:#f92672">.</span>now()
    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10000000</span>):
        sum <span style="color:#f92672">+=</span> i

    ed <span style="color:#f92672">=</span> datetime<span style="color:#f92672">.</span>datetime<span style="color:#f92672">.</span>now()
    inv <span style="color:#f92672">=</span> ed <span style="color:#f92672">-</span> st
    tot_time <span style="color:#f92672">+=</span> inv<span style="color:#f92672">.</span>microseconds <span style="color:#f92672">/</span> (<span style="color:#ae81ff">10</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">6</span>)

<span style="color:#66d9ef">print</span>(tot_time <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>) 
<span style="color:#75715e"># 0.827902s</span>
</code></pre></div><p>我们发现在我的机器上 

<span class="katex">
  \(10^7\)
</span>
  数量级的计算在 10 次平均下是 <code>0.827902</code> 秒，接近一秒。</p>
<p>我们用搜索问题来举例</p>
<blockquote>
<p>如果我们有一个<strong>有序数组</strong> <code>arr</code> ，其中有 

<span class="katex">
  \(10^8\)
</span>
 个数字，这时候给出一数字 <code>n</code> ，求在这个数组中是否有这个数 <code>n</code> ，有则返回 <code>true</code> 反之 <code>false</code> 。<strong>我们要求在 <code>1000ms</code> 时间内完成。</strong></p>
</blockquote>
<p>注意最后一句，如果我们采取枚举的方案来解决这个问题，那么我们根据之前的经验来估算，<strong>需要 

<span class="katex">
  \(\frac{10^8}{10^7} \times 1\)
</span>
 也就是 <code>10</code> 秒</strong>。</p>
<p>由于是有序数组，那么我们来计算一下二分查找的复杂度：</p>
<blockquote>
<p>设数组中有 <code>N</code> 个元素，我们一共需要查询<code>k</code>次，根据这两个条件我们来推导一个 <code>K</code>与<code>N</code>的通项公式（这里面，右边的式子代表在查询完<code>k</code> 次之后，剩余的元素个数）</p>
</blockquote>


<span class="katex">
  \[
f(1) = \frac{N}{2} \\
f(2) = \frac{N}{4} \\ 
... \\
f(k) = \frac{N}{2^k}
\]
</span>

<blockquote>
<p>由于 <code>k</code> 是查询的次数，也就是计算机一次运算的次数，所以我们只需要反解出 <code>k</code> 的值，也就是我们要求解的时间复杂度。我们假设第 <code>k</code> 次查询是最终态，那么说明此时剩余元素只有 <code>1</code> 个了。那么对于最终态的递推式就可以这样描述：</p>
</blockquote>


<span class="katex">
  \[
\frac{N}{2^k}=1\ \ \Rightarrow \ k=log_{2}{N} 
\]
</span>

<p>计算完了发展度之后，我们将 <code>N = 10^7</code> 带入，发现 <code>k = 26.57542</code> 。<strong>也就是说，只需要 27 次上下的计算机运算，也就是 <code>27 / 10^7</code> 约是 <code>0.0000027</code> 秒，就可以完成查询。</strong></p>
<p><strong>所以我们如此分析，通过上限时间来推断大致的算法复杂度，获得提示确定了思路，就可以开始解题了。</strong></p>
<h2 id="土法三取极限估算复杂度">土法三：取极限估算复杂度</h2>
<blockquote>
<p>给你一个无序数组 <code>arr</code> ，其中包含 <code>n</code> 个元素 (<code>1 ≤ n ≤ 10^8</code>)，另外给你一个 <code>k</code> (<code>1 ≤ k ≤ n</code>)。让你求出这个数组中的第 <code>k</code> 大数。要求在 <code>1000ms</code> 时间内完成。</p>
</blockquote>
<p>看完题目第一反映，我们对 <code>arr</code> 数组先做一次降序排序，然后输出 <code>arr[k]</code> 即可。</p>
<p>那么我们开始使用土法二来估算时间，如果我们进行一次排序，假如是快排，那么首先我们需要一个 <code>O(NlogN)</code> 的复杂度来完成。然后还有一次查询，由于通过数组下标直接访问，需要 <code>O(1)</code> 的一次查询。</p>
<p>将 <code>n</code> 的范围右边界带入式中，由于我们知道 <code>NlogN &gt; N</code> ，所以根据上面的经验，我们肯定要花费 <code>10s</code> 以上的时间来处理。虽然我们的想法很好，是对数组做一个预处理，然后再进行其他的算法，但实际上，<strong>由于预处理的复杂度已经远远的超过了其他计算的复杂度，也就是说我们对于一个方案的复杂度考量，往往都是在一个含操作数 N 的代数式中，当 N 取无穷大时，求每个子式子的等价无穷大，然后取最大值作为整个程序的复杂度</strong>。</p>
<p>拿这题为例：</p>


<span class="katex">
  \[
f(n)=nlog_{2}n + 1 \Rightarrow {\lim_{x \to \infty}} \frac{nlog_{2}n}{1} \thicksim \infty   \Rightarrow O_{(nlogn)}
\]
</span>

<p>可能这个还不是很明显，我们再举一个例子：</p>


<span class="katex">
  \[
f(n)=log_{2}n!+nlog_{2}n+n+1
\]
</span>

<p>如果我们遇到这种表达式，我们要如何求解呢？我的土法是分成 2 部：</p>
<h3 id="1-观察后舍去差距较大的">1. 观察后舍去差距较大的</h3>
<p>首先，<code>n</code> 和 <code>1</code> 这两个子式显然要比前面两个都小（或者说肯定比 <code>nlogn</code> 要小），我们把它舍去。</p>


<span class="katex">
  \[
\Rightarrow f'(n)=log_2n! + nlog_{2}n
\]
</span>

<h3 id="2-不确定式两两使用求极限判断等价性">2. 不确定式两两使用求极限，判断等价性</h3>
<p>例如我们得到的 <code>f'(n)</code> 无法判断，那么我就取出这里面两个子式来求等价性：</p>


<span class="katex">
  \[
\begin{aligned}
    &{\lim_{x \to \infty}}\frac{logn!}{nlogn} \\ 
    =&{\lim_{x \to \infty}}\frac{log((\sqrt{2\pi n})\frac{n^n}{e^n})}{nlogn}\\
    =&{\lim_{x \to \infty}}\frac{\frac{1}{2}log(2\pi) + \frac{1}{2}logn + nlogn - nloge}{nlogn} \\
    =&{\lim_{x \to \infty}}(\frac{0.5log(2\pi)}{nlogn}+\frac{1}{2n}+1-\frac{1}{ln\ n})\\
    =&1
\end{aligned}
\]
</span>

<p>所以我们发现剩下的两个式子是等价无穷大的。我们得到整体的时间复杂度：</p>


<span class="katex">
  \[
f'(n) \Rightarrow O(nlog_2n)
\]
</span>

<p>所以我们可以总结出来一个规律，<strong>子式选最大，就是我们要的时间复杂度。</strong></p>
<h2 id="总结">总结</h2>
<p>这篇文章我们讲了：</p>
<ul>
<li>如何结合题目的数据量来估算程序耗时，以及通过复杂度的估算来提示我们要选用什么算法；</li>
<li>耗时和复杂度的关系，<strong>大概就是 

<span class="katex">
  \(10^7\)
</span>
 为一秒</strong>；</li>
<li>取极限来舍去较小的子式，留下的最大子式即可作为整体算法的时间复杂度；</li>
</ul>
<hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      

<div id='gitalk-container'></div>
<script>
  let url = window.location.pathname;
  if (url.startsWith("/algo/docs/")) {
    url = url.slice(11);
  }
  const gitalk = new Gitalk({
    id: url,
    clientID: '86ab0eae3b6d0781c3b6',
    clientSecret: '0394a321f965b11c9f7fbeb81684777cad0f7fea',
    repo: 'algo',
    owner: 'Desgard',
    admin: ['Desgard'],
    
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
</script>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#土法一执行一行约是一次运算">土法一：执行一行约是一次运算</a></li>
        <li><a href="#土法二以经验计算时间">土法二：以经验计算时间</a></li>
        <li><a href="#土法三取极限估算复杂度">土法三：取极限估算复杂度</a>
          <ul>
            <li><a href="#1-观察后舍去差距较大的">1. 观察后舍去差距较大的</a></li>
            <li><a href="#2-不确定式两两使用求极限判断等价性">2. 不确定式两两使用求极限，判断等价性</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












